#!/usr/bin/env python

"""Generate the parent sample of large galaxies.

"""
import os, sys, time, pdb
import numpy as np
import matplotlib.pyplot as plt

import fitsio
from astropy.table import Table, Column, vstack
from astrometry.libkd.spherematch import tree_build_radec, tree_search_radec, match_radec

import LSLGA.io

sampledir = LSLGA.io.sample_dir()
qadir = os.path.join(LSLGA.io.sample_dir(), 'qa')

def _viewer_inspect(cat):
    """Write a little catalog that can be uploaded to the viewer.

    """
    out = cat['GALAXY', 'RA', 'DEC']
    out.rename_column('GALAXY', 'NAME')
    outfile = os.path.join(os.getenv('HOME'), 'tmp', 'viewer.fits')
    print('Writing {} objects to {}'.format(len(cat), outfile))
    out.write(outfile, overwrite=True)

def _imagetool_inspect(cat):
    """Write a little catalog that can be uploaded to
    https://yymao.github.io/decals-image-list-tool/

    """
    galcol = 'GALAXY'
    if not galcol in cat.colnames:
        galcol = 'NAME'
    
    outfile = os.path.join(os.getenv('HOME'), 'tmp', 'inspect.txt')
    print('Writing {} objects to {}'.format(len(cat), outfile))
    with open(outfile, 'w') as ff:
        ff.write('name ra dec\n')
        for ii, (gal, ra, dec) in enumerate(zip(cat[galcol], cat['RA'], cat['DEC'])):
            if gal.strip() == '':
                if 'ALTNAME' in cat.colnames:
                    gal = cat['ALTNAME'][ii].strip().replace(' ', '')
                    if gal == '':
                        gal = 'galaxy'
                else:
                    gal = 'galaxy'
            ff.write('{} {:.6f} {:.6f}\n'.format(gal, ra, dec))

def add_ngc(parent, startindx=5000000):
    """Add in missing NGC galaxies.

    """
    import numpy.ma as ma
    from astropy.io import ascii
    from astrometry.util.starutil_numpy import hmsstring2ra, dmsstring2dec    

    # "Fix" the NGC and IC galaxy names in the parent catalog so we can match,
    # below--
    indx = np.where(['NGC' in gg for gg in parent['GALAXY']])[0]
    for ii in indx:
        gg = parent['GALAXY'][ii]
        gg = gg.strip()
        if len(gg) >= 7: # OK
            if len(gg) > 7:
                print(gg) # e.g., NGC1097A
                #pass
            continue
        else:
            newgg = 'NGC{:04d}'.format(np.int(gg[3:]))
            print('{}-->{}'.format(gg, newgg))
            parent['GALAXY'][ii] = newgg

    indx = np.where(['IC' in gg for gg in parent['GALAXY']])[0]
    for ii in indx:
        gg = parent['GALAXY'][ii]
        gg = gg.strip()
        if len(gg) >= 6: # OK
            if len(gg) > 6:
                print(gg) # e.g., IC1097A
                #pass
            continue
        else:
            newgg = 'IC{:04d}'.format(np.int(gg[2:]))
            print('{}-->{}'.format(gg, newgg))
            parent['GALAXY'][ii] = newgg

    # Now read the OpenNGC catalog--
    names = ('name', 'type', 'ra_hms', 'dec_dms', 'const', 'majax', 'minax',
             'pa', 'bmag', 'vmag', 'jmag', 'hmag', 'kmag', 'sbrightn', 'hubble',
             'cstarumag', 'cstarbmag', 'cstarvmag', 'messier', 'ngc', 'ic',
             'cstarnames', 'identifiers', 'commonnames', 'nednotes', 'ongcnotes')
    NGCfile = os.path.join(sampledir, 'NGC.csv')
    NGC = ascii.read(NGCfile, delimiter=';', names=names)
    print('Read {} galaxies from {}'.format(len(NGC), NGCfile))

    for col in NGC.colnames:
        NGC.rename_column(col, col.upper())

    NGC = NGC[(NGC['RA_HMS'] != 'N/A')]

    ra, dec = [], []
    for _ra, _dec in zip(ma.getdata(NGC['RA_HMS']), ma.getdata(NGC['DEC_DMS'])):
        ra.append(hmsstring2ra(_ra.replace('h', ':').replace('m', ':').replace('s','')))
        dec.append(dmsstring2dec(_dec.replace('d', ':').replace('m', ':').replace('s','')))
    NGC['RA'] = ra
    NGC['DEC'] = dec
    objtype = np.char.strip(ma.getdata(NGC['TYPE']))
    NGC = NGC[np.where(['G' in typ and typ != 'GCl' for typ in objtype])[0]]

    keep = np.where([not 'NED' in nn for nn in NGC['NAME']])[0]
    NGC = NGC[keep]

    NGC['NAME'] = ['tmp-{}'.format(nn.strip().replace(' ', '_')) for nn in NGC['NAME']]
    print('Cutting to {} NGC galaxies with good coordinates.'.format(len(NGC)))

    pdb.set_trace()

    if True:
        NGC = in_footprint(NGC)
        NGC = NGC[NGC['IN_DESI']]
        print('Cutting to {} missing galaxies in the DESI footprint.'.format(len(NGC)))

        # Match against parent--what's missing?
        #m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], NGC['RA'], NGC['DEC'], 5/3600.0, nearest=True)
        missing = np.delete(np.arange(len(NGC)), m2)
        _imagetool_inspect(NGC[missing])
        pdb.set_trace()

    # Make the supplemental catalog "look" like the parent Hyperleda catalog.
    NGC.rename_column('NAME', 'GALAXY')
    NGC.rename_column('MAJAX', 'D25') # [arcmin]
    NGC.rename_column('BMAG', 'MAG')
    NGC['BA'] = NGC['MINAX'] / NGC['D25']
    
    out = Table()
    for col in parent.colnames:
        out[col] = np.zeros(len(NGC), dtype=parent[col].dtype)
    for col in NGC.colnames:
        if col in out.colnames:
            out[col] = NGC[col]
            
    out['OBJTYPE'] = 'G'
    out['SB_D25'] = out['MAG'] + 2.5 * np.log10( np.pi * (60/2)**2 ) + 5 * np.log10(out['D25'])

    parent = vstack((parent, out))

    return parent
    
def add_rc3(parent, startindx=4000000):
    """Add in missing RC3 galaxies.

    """
    print('Supplementing the LSGLA with missing RC3 galaxies.')

    rc3file = os.path.join(os.getenv('CATALOGS_DIR'), 'rc3', 'rc3_parsed.fits.gz')
    rc3 = Table.read(rc3file)
    print('Read {} galaxies from {}'.format(len(rc3), rc3file))

    rc3.add_column(Column(name='LSLGA_ID', data=startindx + np.arange(len(rc3))), index=0)

    # Code used for visual inspections--
    if False:
        gal = np.array([gg.strip().replace(' ', '') for gg in rc3['NAME']])

        keep = np.where((rc3['D25_MAJ'] > 20/60.) *
                        (gal != 'SMC') * (gal != 'LMC') *
                        (gal != 'Fornax') *
                        (gal != 'Sculptor') *
                        (gal != 'UrsaMinor') *
                        (gal != 'Draco') *
                        (gal != 'Carina'))[0] 
        print('Keeping {}/{} galaxies with D(25)>20 arcsec'.format(len(keep), len(rc3)))
        rc3 = rc3[keep]

        # match on PGC number
        pgc = [np.int(pgc.replace('PGC', '').replace('a+b', '')) for pgc in rc3['PGC']]
        missing = np.logical_not(np.isin(pgc, parent['PGC']))

        rc3 = rc3[missing]
        rc3 = in_footprint(rc3)
        rc3 = rc3[rc3['IN_DESI']]
        print('Cutting to {} missing galaxies in the DESI footprint.'.format(len(rc3)))

        #m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], rc3['RA'], rc3['DEC'], 10/3600.0, nearest=True)
        #missing = np.delete(np.arange(len(rc3)), m2)
        #rc3[missing]
        #_imagetool_inspect(rc3)

    # Add galaxies in by hand, based on visual inspection--
    keepgals = np.array([
        'ESO350-38',
        #'UGC504', # Hyperleda diameter fixed in fix_byhand()
        'ESO79-13', 'MCG-1-3-72', 'ESO296-11',
        'NGC526', 'NGC596', 'UGCA20', 'NGC680', 'ESO298-39', 'NGC1097A',
        'ESO356-14',
        'ESO116-15',
        'ESO248-6',
        'NGC1382', 'ESO302-15',
        'ESO201-10',
        'ESO118-30',
        #'ESO119-23', # Hyperleda diameter fixed in fix_byhand()
        'ESO159-16',
        #'ESO488-31', # Hyperleda diameter fixed in fix_byhand()
        'UGC3694', 'UGC4528', 'MCG-1-25-6',
        'UGC5162',
        #'A0943+56', # Hyperleda diameter fixed in fix_byhand()
        'UGC5482',
        'MCG1-32-96',
        'NGC4858',
        #'MCG-1-33-83', # <<30 arcsec
        #'IC4212', # Hyperleda diameter fixed in fix_byhand()
        'NGC6050',
        #'ESO286-52', # in Hyperleda as NGC7012?
        'ESO288-40',
        'NGC7592', 
        'ESO192-11'])
    gal = np.array([gg.strip().replace(' ', '') for gg in rc3['NAME']])
    alt = np.array([gg.strip().replace(' ', '') for gg in rc3['ALTNAME']])

    keep = []
    for keepgal in keepgals:
        ww = np.where(keepgal == gal)[0]
        if len(ww) == 0:
            ww = np.where(keepgal == alt)[0]
        if len(ww) == 0:
            pdb.set_trace()
        keep.append(ww)
    keep = np.hstack(keep)
    
    #keep = np.where( (gal == 'ESO350-38') or
    #                 (gal == )
    #                 )[0]
    print('Keeping {} RC3 galaxies.'.format(len(keep)))
    #_imagetool_inspect(rc3[keep])

    rc3 = rc3[keep]

    # Make the supplemental catalog "look" like the parent Hyperleda catalog.
    rc3['GALAXY'] = keepgals
    rc3['BA'] = rc3['D25_MIN'] / rc3['D25_MAJ']
    rc3.rename_column('D25_MAJ', 'D25')
    rc3.rename_column('BMAG', 'MAG')

    pgc = [np.int(pgc.replace('PGC', '').replace('a+b', '')) for pgc in rc3['PGC']]
    rc3.rename_column('PGC', 'BIGPGC')
    rc3['PGC'] = pgc

    fix = np.where(rc3['GALAXY'] == 'ESO350-38')[0]
    rc3['RA'][fix], rc3['DEC'][fix] = 9.219583, -33.554722 # from NED

    fix = np.where(rc3['GALAXY'] == 'MCG-1-3-72')[0]
    rc3['PA'][fix] = 45 # by eye
    rc3['MAG'][fix] = 17.55

    fix = np.where(rc3['GALAXY'] == 'UGCA20')[0]
    rc3['MAG'][fix] = 16.05

    fix = np.where(rc3['GALAXY'] == 'UGC4258')[0]
    rc3['MAG'][fix] = 16.14

    fix = np.where(rc3['GALAXY'] == 'MCG-1-25-6')[0]
    rc3['MAG'][fix] = 13.99

    fix = np.where(rc3['GALAXY'] == 'UGC5162')[0]
    rc3['MAG'][fix] = 15.94

    fix = np.where(rc3['GALAXY'] == 'UGC5482')[0]
    rc3['MAG'][fix] = 16.97

    fix = np.where(rc3['GALAXY'] == 'UGC5482')[0]
    rc3['MAG'][fix] = 16.97

    fix = np.where(rc3['GALAXY'] == 'NGC6050')[0]
    rc3['MAG'][fix] = 15.4

    fix = np.where(rc3['GALAXY'] == 'ESO116-15')[0]
    rc3['PA'][fix] = 95 # by eye

    fix = np.where(rc3['GALAXY'] == 'MCG1-32-96')[0]
    rc3['PA'][fix] = 45 # by eye

    fix = np.where(rc3['GALAXY'] == 'ESO118-30')[0]
    rc3['D25'][fix] = 0.1*10**1.25
    rc3['BA'][fix] = 10**(-0.26)
    rc3['PA'][fix] = 64.3
    rc3['MAG'][fix] = 14.3

    fix = np.where(rc3['GALAXY'] == 'ESO248-6')[0]
    rc3['D25'][fix] = 0.1*10**1.21
    rc3['BA'][fix] = 10**(-0.41)
    rc3['PA'][fix] = 12.5
    rc3['MAG'][fix] = 15.05

    fix = np.where(rc3['GALAXY'] == 'ESO356-14')[0]
    rc3['D25'][fix] = 0.1*10**0.94
    rc3['BA'][fix] = 10**(-0.12)
    rc3['PA'][fix] = 127.7
    rc3['MAG'][fix] = 14.77

    fix = np.where(rc3['GALAXY'] == 'NGC7592')[0]
    rc3['D25'][fix] = 0.1*10**1.18
    rc3['BA'][fix] = 10**(-0.12)
    rc3['PA'][fix] = 85.0
    rc3['MAG'][fix] = 14.5

    #fix = rc3['MAG'] < 0
    #rc3['MAG'][fix] = 15.0 # hack!

    #fix = np.where(rc3['GALAXY'] == 'MCG-1-33-83')[0]
    #rc3['D25'][fix] = 
    
    out = Table()
    for col in parent.colnames:
        out[col] = np.zeros(len(rc3), dtype=parent[col].dtype)
    for col in rc3.colnames:
        if col in out.colnames:
            out[col] = rc3[col]
            
    out['OBJTYPE'] = 'G'
    out['SB_D25'] = out['MAG'] + 2.5 * np.log10( np.pi * (60/2)**2 ) + 5 * np.log10(out['D25'])
    
    parent = vstack((parent, out))
    
    return parent
        
def in_footprint(parent, nside=512):
    """Find all galaxies in the DESI footprint.

    """
    import healpy as hp
    import LSLGA.misc
    
    #tiles = LSLGA.io.read_desi_tiles(verbose=verbose)
    #indesi = LSLGA.misc.is_point_in_desi(tiles, parent['RA'], parent['DEC']).astype(bool)

    parentpix = LSLGA.misc.radec2pix(nside, parent['RA'], parent['DEC'])
    #parentpix = np.hstack((parentpix, hp.pixelfunc.get_all_neighbours(nside, parentpix, nest=True).flatten()))

    dr = 'dr9'
    drdir = os.path.join(sampledir, dr)

    bands = ('g', 'r', 'z')
    camera = ('90prime', 'mosaic', 'decam')

    indesi = dict()
    for cam in camera:
        for band in bands:
            indesi.update({'{}_{}'.format(cam, band): np.zeros(len(parent), dtype=bool)})

    #indesi = np.zeros(len(parent), dtype=bool)
    t0 = time.time()
    for cam, radius in zip(camera, (0.44, 0.21, 0.17)):
        if False:
            from astrometry.libkd.spherematch import trees_match, tree_open
            kdccds = tree_open(os.path.join(drdir, 'survey-ccds-{}-{}.kd.fits'.format(cam, dr)))
            I, J, dd = trees_match(kdparent, kdccds, np.radians(radius))#, nearest=True)
        else:
            ccdsfile = os.path.join(drdir, 'survey-ccds-{}-{}.kd.fits'.format(cam, dr))
            ccds = fitsio.read(ccdsfile)
            print('Read {} CCDs from {}'.format(len(ccds), ccdsfile))

            for band in bands:
                ww = ccds['filter'] == band
                if np.sum(ww) > 0:
                    # add the neighboring healpixels to protect against edge effects
                    ccdpix = LSLGA.misc.radec2pix(nside, ccds['ra'][ww], ccds['dec'][ww])
                    ccdpix = np.hstack((ccdpix, hp.pixelfunc.get_all_neighbours(nside, ccdpix, nest=True).flatten()))
                    if np.sum(ccdpix == -1) > 0: # remove the "no neighbors" healpixel, if it exists
                        ccdpix = np.delete(ccdpix, np.where(ccdpix == -1)[0])
                    I = np.isin(parentpix, ccdpix)
                    indesi['{}_{}'.format(cam, band)][I] = True
                else:
                    I = [False]
                #print('Found {} galaxies in {} {} footprint in {:.1f} sec'.format(np.sum(I), cam, time.time() - t0))
                print('  Found {} galaxies in {} {} footprint.'.format(np.sum(I), cam, band))
    print('Total time to find galaxies in footprint = {:.1f} sec'.format(time.time() - t0))
    
    parent['IN_DESI_NORTH'] = indesi['90prime_g'] | indesi['90prime_r'] | indesi['mosaic_z']
    parent['IN_DESI_NORTH_GRZ'] = indesi['90prime_g'] & indesi['90prime_r'] & indesi['mosaic_z']

    parent['IN_DESI_SOUTH'] = indesi['decam_g'] | indesi['decam_r'] | indesi['decam_z']
    parent['IN_DESI_SOUTH_GRZ'] = indesi['decam_g'] & indesi['decam_r'] & indesi['decam_z']
    
    parent['IN_DESI'] = parent['IN_DESI_NORTH'] | parent['IN_DESI_SOUTH']
    parent['IN_DESI_GRZ'] = parent['IN_DESI_NORTH_GRZ'] | parent['IN_DESI_SOUTH_GRZ']

    #plt.scatter(parent['RA'], parent['DEC'], s=1)
    #plt.scatter(parent['RA'][indesi], parent['DEC'][indesi], s=1)
    #plt.xlim(360, 0)
    #plt.show()

    #bb = parent[parent['IN_DESI_NORTH_GRZ'] & parent['IN_DESI_SOUTH_GRZ']]
    #plt.scatter(bb['RA'], bb['DEC'], s=1)
    #plt.xlim(300, 90) ; plt.ylim(30, 36)
    #plt.axhline(y=32.375, color='k')
    #plt.xlabel('RA') ; plt.ylabel('Dec')
    #plt.show()
    
    print('  Identified {}/{} ({:.2f}%) galaxies inside and {}/{} ({:.2f}%) galaxies outside the DESI footprint.'.format(
        np.sum(parent['IN_DESI']), len(parent), 100*np.sum(parent['IN_DESI'])/len(parent), np.sum(~parent['IN_DESI']),
        len(parent), 100*np.sum(~parent['IN_DESI'])/len(parent)))

    return parent

def near_stars(parent):
    """Flag galaxies near bright stars.

    """
    tycho = LSLGA.io.read_tycho(verbose=True)
    kdparent = tree_build_radec(parent['RA'], parent['DEC'])

    nearstar = np.zeros( len(parent) ).astype(bool)
    for star in tycho:
        I = tree_search_radec(kdparent, star['RA'], star['DEC'], star['RADIUS'])
        if len(I) > 0:
            nearstar[I] = True
    print('  Found {}/{} ({:.2f}%) galaxies near a bright (Tycho-2) star.'.format(
        np.sum(nearstar), len(parent), 100*np.sum(nearstar)/len(parent)))
    parent['NEAR_BRIGHTSTAR'] = nearstar

    return parent, kdparent
    
def apply_diamcut(parent, d25min, d25max):
    """Apply the diameter cuts.

    Note that a D(25) maximum cut of 100 arcmin throws out LMC=ESO056-115,
    SMC=NGC0292, M31=NGC224, and the Sagittarius Dwarf.

                GALAXY                    RA                 DEC            D25
                str29                  float64             float64        float32
    ----------------------------- ------------------ ------------------- ----------
    ESO056-115                            80.8941495  -69.75610400000001   645.6542
    SAGITTARIUS_DWARF_SPHEROIDAL          283.762899         -30.4784401  449.77997
    NGC0292                               13.1583105  -72.80022659999999  299.91626
    NGC0224                               10.6846845          41.2689778  177.82794

    """
    diamcut = (parent['D25'] >= d25min) * (parent['D25'] <= d25max)
    print('  Removed {}/{} ({:.2f}%) objects with D(25) < {:.3f} arcsec and D(25) > {:.3f} arcmin.'.format(
        np.sum(~diamcut), len(parent), 100*np.sum(~diamcut)/len(parent), d25min*60, d25max))
    if np.sum(diamcut) > 0:
        #parent[~diamcut].write(os.path.join(qadir, 'LSLGA-{}-diamcut.fits'.format(version)), overwrite=True)
        parent = parent[diamcut]

    return parent

def fix_byhand(parent):
    """Repair incorrect diameters and other properties in Hyperleda "by hand".

    See also WXSC - https://vislab.idia.ac.za/research
    
    """
    print('Repairing some quantities by-hand.')

    # UGC504
    # Use RC3 values
    fix = np.where(parent['PGC'] == 2882)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 1.175
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])
          
    # Maffei2
    # Use https://github.com/moustakas/LSLGA/blob/master/doc/compare-wxsc-largest-galaxies.ipynb
    fix = np.where(parent['PGC'] == 10217)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 2 * 8.50
        parent['PA'][fix] = 27.7
        parent['BA'][fix] = 0.44
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])
        
    # UGC05302
    # https://ned.ipac.caltech.edu/byname?objname=UGC05302&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 28563)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1*10**1.29
        parent['PA'][fix] = 117
        parent['BA'][fix] = 10**(-0.06)
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])
        
    # PGC061191 - fix by eye
    fix = np.where(parent['PGC'] == 61191)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.8
        parent['BA'][fix] = 1.0
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])
          
    # PGC008356 - use RC3 diameters but PA from SDSS
    # https://ned.ipac.caltech.edu/byname?objname=PGC008356&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 8356)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1*10**0.74
        parent['PA'][fix] = 105
        parent['BA'][fix] = 10**(-0.38)
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])
        
    # [PT2011]53, wrong PA
    fix = np.where(parent['GALAXY'] == '[PT2011]53')[0]
    if len(fix) > 0:
        parent['PA'][fix] = 45.0
    
    # PGC1035237, Leda coordiantes are totally wrong!
    fix = np.where(parent['PGC'] == 1035237)[0]
    if len(fix) > 0:
        parent['RA'][fix] = 31.8505
        parent['DEC'][fix] = -6.2346

    # PGC040184=VCC0619, use geometry from NED
    # https://ned.ipac.caltech.edu/byname?objname=PGC40184&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 40184)[0]
    if len(fix) > 0:
        parent['RA'][fix] = 185.770708
        parent['DEC'][fix] = 15.931667
        parent['PA'][fix] = 70.0 # eye-balled
        
    # NGC5474, use D25, PA, and BA from NED
    # https://ned.ipac.caltech.edu/byname?objname=ngc5474&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 50216)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1*10**1.68
        parent['PA'][fix] = 97.5
        parent['BA'][fix] = 10**(-0.05)
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # PGC170137, fix the PA--not sure why it's not populated
    # http://leda.univ-lyon1.fr/fG.cgi?n=a103&o=PGC170137
    fix = np.where(parent['PGC'] == 170137)[0]
    if len(fix) > 0:
        parent['PA'][fix] = 42.0

    # NGC4526, use PA from NED
    # https://ned.ipac.caltech.edu/byname?objname=ngc779&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 41772)[0]
    if len(fix) > 0:
        parent['PA'][fix] = 113.0

    # PGC007900, use D25 from NED and visually determined PA
    # https://ned.ipac.caltech.edu/byname?objname=PGC007900&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 7900)[0]
    if len(fix) > 0:
        parent['PA'][fix] = 65.0
        parent['D25'][fix] = 0.1 * 10**1.51 # [arcmin]
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])
        
    # NGC5364, use PA and D25 from RC3/NED
    # https://ned.ipac.caltech.edu/byname?objname=ngc5364&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 49555)[0]
    if len(fix) > 0:
        parent['PA'][fix] = 30.0
        parent['BA'][fix] = 0.65
        parent['D25'][fix] = 0.1 * 10**1.83 # [arcmin]
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # NGC0779, use value from RC3
    # https://ned.ipac.caltech.edu/byname?objname=ngc779&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 7544)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1 * 10**1.6 # [arcmin]
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # NGC4448, use values from RC3
    # https://ned.ipac.caltech.edu/byname?objname=ngc4448&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 40988)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1 * 10**1.59 # [arcmin]
        parent['BA'][fix] = 10**(-0.44)
        parent['PA'][fix] = 94.0
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # NGC4395 https://github.com/moustakas/LSLGA/issues/28
    fix = np.where(parent['PGC'] == 40596)[0] 
    if len(fix) > 0:
        parent['D25'][fix] = 12.8 # [arcmin]
        parent['BA'][fix] = 0.833
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # NGC2366 https://github.com/moustakas/LSLGA/issues/29
    fix = np.where(parent['PGC'] == 21102)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 8.8964 # [arcmin]
        parent['BA'][fix] = 0.5263
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # IC4212
    fix = np.where(parent['PGC'] == 45845)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1*10**1.49
        parent['BA'][fix] = 10**(-0.11)
        parent['PA'][fix] = 140
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # PGC28111
    fix = np.where(parent['PGC'] == 28111)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1*10**0.62
        parent['BA'][fix] = 10**(-0.11)
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # PGC075458=ESO488-31
    fix = np.where(parent['PGC'] == 75458)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.977
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # PGC16395=ESO119-23
    fix = np.where(parent['PGC'] == 16395)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 1.445
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # PGC011986 - coordinates are totally wrong!
    fix = np.where(parent['PGC'] == 11986)[0]
    if len(fix) > 0:
        parent['RA'][fix] = 48.285686
        parent['DEC'][fix] = -50.562612

    return parent

def add_localgroup_dwarfs(parent):
    """LG dwarfs

    """
    from astropy.table import hstack
    
    print('Adding in the LG dwarfs.')
    dwarfs = LSLGA.io.read_localgroup_dwarfs()
    #dwarfs = dwarfs[(~dwarfs['IGNORE']) * (~dwarfs['RESOLVED'])] # remove these below

    m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], dwarfs['RA'], dwarfs['DEC'], 60/3600.0, nearest=True)
    dwarfs['PGC'][m2] = parent['PGC'][m1]
   
    if False:
        print(hstack((parent['GALAXY', 'RA', 'DEC', 'D25'][m1], dwarfs['GALAXY', 'ONAME', 'RA', 'DEC', 'D25', 'RECNO'][m2])))
        from astropy.stats import sigma_clipped_stats
        print(sigma_clipped_stats(parent['D25'][m1]/dwarfs['D25'][m2], sigma=3))
        fig, ax = plt.subplots(1, 3, figsize=(12, 4))
        ax[0].scatter(parent['D25'][m1], dwarfs['D25'][m2])
        ax[1].scatter(parent['PA'][m1], dwarfs['PA'][m2]) ; ax[1].set_xlim(-5, 184) ; ax[1].set_ylim(-5, 184)
        ax[2].scatter(parent['BA'][m1], dwarfs['BA'][m2]) ; ax[2].set_xlim(0, 1) ; ax[2].set_ylim(0, 1)
        plt.show()

    # Make the dwarfs catalog "look" like the parent Hyperleda catalog and assign IDs.
    moredwarfs = Table()
    for col in parent.colnames:
        moredwarfs[col] = np.zeros(len(dwarfs), dtype=parent[col].dtype)
    for col in dwarfs.colnames:
        if col in moredwarfs.colnames:
            moredwarfs[col] = dwarfs[col]

    # Remove the duplicates and stack.
    keep = np.delete(np.arange(len(parent)), m1)
    parent = vstack((parent[keep], moredwarfs))
    #parent = parent[np.argsort(parent['LSLGA_ID'])]

    # Finally, remove the dwarfs that are so sparse that we don't care about
    # them and the dwarfs that are so resolved (Fornax & Sculptor) that we
    # actually want to treat them as globular cluster (i.e., "force PSF").
    rem = np.where(np.logical_or(dwarfs['IGNORE'], dwarfs['RESOLVED']))[0]
    m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], dwarfs['RA'][rem],
                              dwarfs['DEC'][rem], 60/3600.0, nearest=True)
    keep = np.delete(np.arange(len(parent)), m1)
    parent = parent[keep]

    return parent

def add_dr8_candidates(parent, startindx=6000000):
    """Read the set of "large" galaxies identified by Stephanie Juneau from the DR8
    catalogs.

    """
    print('Supplementing the LSGLA with the DR8 large galaxies.')

    northfile = os.path.join(sampledir, 'dr8galaxies_gt14_north.fits')
    north = Table(fitsio.read(northfile, upper=True))
    print('Read {} galaxies from {}'.format(len(north), northfile))

    southfile = os.path.join(sampledir, 'dr8galaxies_gt14_south.fits')
    south = Table(fitsio.read(southfile, upper=True))
    print('Read {} galaxies from {}'.format(len(south), southfile))

    nkeep = np.where((north['DEC'] > 32.375) * (north['VI_FLAG'] == 'Y'))[0]
    skeep = np.where((south['DEC'] < 32.375) * (south['VI_FLAG'] == 'Y'))[0]

    #print('Add in a minimum d25 for the sdss-supplemented galaxies!!!!!!!!!')

    if False:
        plt.scatter(north['RA'], north['DEC'], label='North')
        plt.scatter(south['RA'], south['DEC'], label='South')
        plt.scatter(north['RA'][nkeep], north['DEC'][nkeep], label='North Keep')
        plt.scatter(south['RA'][skeep], south['DEC'][skeep], label='South Keep') 
        plt.legend() ; plt.axhline(y=32.375, color='k') ; plt.show()

    # Resolve north & south
    supp = vstack((north[nkeep], south[skeep]))

    # Assign IDs starting at startindx.
    supp.add_column(Column(name='LSLGA_ID', data=startindx + np.arange(len(supp))), index=0)
    supp.rename_column('TYPE', 'OBJTYPE')

    # Make the supplemental catalog "look" like the parent Hyperleda catalog.
    out = Table()
    for col in parent.colnames:
        out[col] = np.zeros(len(supp), dtype=parent[col].dtype)
    for col in supp.colnames:
        if col in out.colnames:
            out[col] = supp[col]
    #out['OBJTYPE'] = 'G'

    # Get the geometry from the Tractor fit--
    #print(set(supp['TYPE']))
    for igal, gal in enumerate(supp):
        out['GALAXY'][igal] = 'DR8-{}-{}'.format(supp['BRICKID'][igal], supp['OBJID'][igal])
        #out['GALAXY'][igal] = 'DR8-{}'.format(supp['LS_ID'][igal])
        out['MAG'][igal] = supp['MAG_R'][igal]

        typ = gal['OBJTYPE'].strip()
        if typ == 'DEV':
            ee = np.hypot(gal['SHAPEDEV_E1'], gal['SHAPEDEV_E2'])
            r50 = gal['SHAPEDEV_R'] # [arcsec]
            pa = 180 - (-np.rad2deg(np.arctan2(gal['SHAPEDEV_E2'], gal['SHAPEDEV_E1']) / 2))
        elif typ == 'EXP':
            ee = np.hypot(gal['SHAPEEXP_E1'], gal['SHAPEEXP_E2'])
            r50 = gal['SHAPEEXP_R'] # [arcsec]
            pa = 180 - (-np.rad2deg(np.arctan2(gal['SHAPEEXP_E2'], gal['SHAPEEXP_E1']) / 2))
        elif typ == 'COMP':
            fracdev = gal['FRACDEV']
            eeexp = np.hypot(gal['SHAPEEXP_E1'], gal['SHAPEEXP_E2'])
            eedev = np.hypot(gal['SHAPEDEV_E1'], gal['SHAPEDEV_E2'])
            paexp = 180 - (-np.rad2deg(np.arctan2(gal['SHAPEEXP_E2'], gal['SHAPEEXP_E1']) / 2))
            padev = 180 - (-np.rad2deg(np.arctan2(gal['SHAPEDEV_E2'], gal['SHAPEDEV_E1']) / 2))
            r50exp = gal['SHAPEEXP_R']
            r50dev = gal['SHAPEDEV_R']
            if False:
                ee = fracdev * eedev + (1 - fracdev) * eeexp
                pa = fracdev * padev + (1 - fracdev) * paexp            
                r50 = fracdev * r50dev + (1 - fracdev) * r50exp # [arcsec]
            else:
                if r50dev >= r50exp:
                    ee = eedev
                    pa = padev
                    r50 = r50dev
                else:
                    ee = eeexp
                    pa = paexp
                    r50 = r50exp
        else:
            print('Doom!')
            pdb.set_trace()
                
        ba = (1 - ee) / (1 + ee)
        pa = pa % 180
        theta = (270 - pa) % 180
        d25 = 1.4 * 2 * r50 / 60.0 # radius-->diameter and then r50-->R(25) fudge factor [arcmin]

        #if (supp['BRICKID'][igal] == 628872) * (supp['OBJID'][igal] == 3436):
        #    pdb.set_trace()

        out['BA'][igal] = ba.astype('f4')
        out['PA'][igal] = pa.astype('f4')
        out['D25'][igal] = d25.astype('f4')

    out['SB_D25'] = (out['MAG'] + 2.5 * np.log10(np.pi * (60/2)**2) + 5 * np.log10(out['D25'])).astype('f4')

    # Double-check for duplicates
    m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], out['RA'], out['DEC'], 3/3600.0, nearest=True)
    assert(len(m1) == 0)

    parent = vstack((parent, out))

    return parent

def remove_spurious(parent):
    """Remove spurious galaxies.

    """
    from legacyhalos.misc import is_in_ellipse

    # Read the file from Schlegel--
    rejfile = os.path.join(sampledir, 'lslga-dr8-psf-reject.txt')
    rejid, rejra, rejdec = np.loadtxt(rejfile, unpack=True)
    print('Read {} spurious galaxies from {}'.format(len(rejid), rejfile))
    rejgal = parent[np.isin(parent['LSLGA_ID'], rejid)]['GALAXY'].data

    rejfile = os.path.join(sampledir, 'lslga-spurious.txt')
    spurgal = np.loadtxt(rejfile, dtype=str)
    print('Read spurious {} galaxies from {}'.format(len(spurgal), rejfile))

    rejgalfinal = np.unique(np.concatenate((spurgal, rejgal)))

    gal = np.array([onegal.strip() for onegal in parent['GALAXY']])
    #rejgal = parent[~np.isin(parent['GALAXY'], rejgalaxies)]

    notspuriouscut = ~np.isin(gal, rejgalfinal)

    print('  Removed {}/{} ({:.2f}%) known spurious galaxies.'.format(
        np.sum(~notspuriouscut), len(parent), 100*np.sum(~notspuriouscut)/len(parent)))
    if np.sum(notspuriouscut) > 0:
        parent = parent[notspuriouscut]

    # Require a magnitude estimate. Unfortunately many of these are real
    # galaxies, although either their positions or their geometry is totally
    # unreliable.
    #_viewer_inspect(parent[np.isnan(parent['MAG']) * parent['IN_DESI']])
    magcut = np.isfinite(parent['MAG'])
    print('  Removed {}/{} ({:.2f}%) objects with no magnitude estimate.'.format(
        np.sum(~magcut), len(parent), 100*np.sum(~magcut)/len(parent)))
    if np.sum(magcut) > 0:
        #parent[~magcut].write(os.path.join(sandboxdir, 'LSLGA-{}-nomagnitude.fits'.format(version)), overwrite=True)
        parent = parent[magcut]

    # Toss out all SDSS and 2MASS galaxies "near" another large galaxy.  Many of
    # these are spurious and the ones that are not usually have compromised
    # diameters. Hopefully the real galaxies we toss out will be fixed by visual
    # inspection and/or will be picked up by the standard pipeline.
    kdparent = tree_build_radec(parent['RA'], parent['DEC'])
    
    indx = ['SDSS' in gg or '2MAS' in gg for gg in parent['GALAXY']]
    #indx = np.where(parent['IN_DESI'] * )[0]
    host = np.where(parent['IN_DESI'] * (parent['D25'] > 0.5) * np.logical_not(indx))[0]
    
    sdssingal = np.zeros(len(parent), dtype=bool)
    for pp in parent[host]:
        I = tree_search_radec(kdparent, pp['RA'], pp['DEC'], pp['D25'] / 1.5 / 60) # 1.7 instead of 2...
        if len(I) > 1: # don't count the host galaxy itself
            these = np.array(['SDSS' in gg or '2MAS' in gg for gg in parent['GALAXY'][I]])
            if np.sum(these) > 0:
                sdssingal[I[these]] = True
        
        #phi = 180 - pp['PA']
        #ab = 1. / pp['BA']
        #e = (ab - 1) / (ab + 1)
        #ee = -np.log(1 - e)
        #angle = np.deg2rad(2. * (-phi))
        #e1 = ee * np.cos(angle)
        #e2 = ee * np.sin(angle)
        #inell = is_in_ellipse(parent['RA'][indx], parent['DEC'][indx],
        #                      pp['RA'], pp['DEC'], pp['D25'] / 2, e1, e2)
        #if np.sum(inell) > 0:
        #    pdb.set_trace()
        
    #_imagetool_inspect(parent[inspect])
    
    print('  Removed {}/{} ({:.2f}%) SDSS/2MASS galaxies inside another large galaxy.'.format(
        np.sum(sdssingal), len(parent), 100*np.sum(sdssingal)/len(parent)))    
    if np.sum(sdssingal) > 0:
        parent = parent[~sdssingal]
    
    # Visually inspect all the SDSS galaxies above a certain surface brightness;
    # most of these are spurious, but there are many we want to keep.
    #w1 = np.where(parent['IN_DESI'] * (parent['SB_D25'] > 26) * (parent['D25'] <= 0.9))[0]
    #w2 = np.where(['SDSS' in gg for gg in parent['GALAXY'][w1]])[0]
    #_imagetool_inspect(parent[w1][w2])

    #ww = np.where(parent['IN_DESI'] * (parent['SB_D25'] > 27))[0]
    #_imagetool_inspect(parent[ww])
    
    #ww = np.where(parent['IN_DESI'])[0]
    #plt.clf() #; plt.scatter(parent['MAG'][ww], parent['SB_D25'][ww], s=1)
    ##plt.scatter(parent['MAG'][ww][ii], parent['SB_D25'][ww][ii], s=1, color='orange', alpha=0.5)
    #plt.clf() ; plt.scatter(parent['D25'][ww], parent['SB_D25'][ww], s=1)
    ##plt.scatter(parent['D25'][ww][ii], parent['SB_D25'][ww][ii], s=1, color='orange', alpha=0.5)
    ##plt.axhline(y=27, ls='-', color='k')
    #plt.xscale('log')
    #plt.savefig('junk3.png')
    
    # Check all the galaxies with b/a=1--they're OK!
    #_viewer_inspect(parent[(parent['BA']==1) * parent['IN_DESI']])

    #print('  Removed {}/{} ({:.2f}%) low surface-brightness galaxies.'.format(
    #    np.sum(lsbcut), len(parent), 100*np.sum(lsbcut)/len(parent)))
    #if np.sum(lsbcut) > 0:
    #    #parent[lsbcut].write(os.path.join(sandboxdir, 'LSLGA-{}-lsb.fits'.format(version)), overwrite=True)
    #    parent = parent[~lsbcut]

    #sdss2massgal = np.array(['SDSS' in gg or '2MAS' in gg or '[' in gg or 'WINGS' in gg for gg in parent['GALAXY']])
    #print('  Removed {}/{} ({:.2f}%) SDSS/2MASS galaxies and galaxies with square brackets in their name!'.format(
    #    np.sum(sdss2massgal), len(parent), 100*np.sum(sdss2massgal)/len(parent)))
    #if np.sum(sdss2massgal) > 0:
    #    if sandbox:
    #        parent[sdss2massgal].write(os.path.join(sandboxdir, 'LSLGA-{}-sdss2mass.fits'.format(
    #            version)), overwrite=True)
    #    parent = parent[~sdss2massgal]

    return parent

def build_group_catalog(cat, mfac=2.0, dmax=10.0/60.0):
    """dmax in arcmin

    Group LSLGA galaxies together where their circular radii would overlap.  Use
    the catalog D25 diameters (in arcmin) multiplied by a scaling factor MFAC.
    The output catalog adds the column GROUP_ID which is unique for each group.
    The column MULT_GROUP is the multiplicity of that galaxy's group.

    """
    from pydl.pydlutils.spheregroup import spheregroup
    from astrometry.util.starutil_numpy import degrees_between

    nchar = np.max([len(gg) for gg in cat['GALAXY']])+6 # add six characters for "_GROUP"
    
    t0 = time.time()
    cat.add_column(Column(name='GROUP_ID', data=np.zeros(len(cat), dtype=np.int)-1))
    cat.add_column(Column(name='GROUP_NAME', length=len(cat), dtype='<U{}'.format(nchar)))
    cat.add_column(Column(name='GROUP_MULT', data=np.zeros(len(cat), dtype=np.int16)))
    cat.add_column(Column(name='GROUP_PRIMARY', data=np.zeros(len(cat), dtype=bool)))
    cat.add_column(Column(name='GROUP_RA', length=len(cat), dtype='f8')) # diameter-weighted center
    cat.add_column(Column(name='GROUP_DEC', length=len(cat), dtype='f8'))
    cat.add_column(Column(name='GROUP_DIAMETER', length=len(cat), dtype='f4'))

    #ww = np.where((parent['RA'] > 177) * (parent['RA'] < 178) * (parent['DEC'] > -1.5) * (parent['DEC'] < -0.5))[0]
    #ww = np.where((parent['RA'] > 200) * (parent['RA'] < 240) * (parent['DEC'] > 20))[0]
    #ww = np.where((parent['RA'] > 193) * (parent['RA'] < 196) * (parent['DEC'] > 26) * (parent['DEC'] < 30))[0]
    
    # Initialize a unique group number for each galaxy
    gnum = np.arange(len(cat)).astype(np.int)
    mgrp = np.ones(len(cat)).astype(np.int16)
    
    # First group galaxies within 10 arcmin, setting those to have the same
    # group number
    t0 = time.time()
    print('Spheregrouping took...', end='')
    ingroup, group_mult, firstgroup, nextgroup = spheregroup(cat['RA'], cat['DEC'], dmax)
    print('...{:.3f} min'.format((time.time() - t0)/60))

    ngroup = np.count_nonzero(firstgroup != -1)
    for ii in np.arange(ngroup):
        #print(ii, ngroup)
        nn = group_mult[ii] # number of galaxies in this group
        if nn > 1:
            # Build INDX as the indices of all objects in this grouping
            indx = np.zeros(nn, dtype=int)
            indx[0] = firstgroup[ii]
            for jj in np.arange(nn-1):
                indx[jj+1] = nextgroup[indx[jj]]
            # Look at all pairs within this grouping to see if they should be connected.
            for jj in np.arange(nn-1):
                for kk in np.arange(jj, nn):
                    dd = degrees_between(cat['RA'][indx[jj]], cat['DEC'][indx[jj]], cat['RA'][indx[kk]], cat['DEC'][indx[kk]])
                    # If these two galaxies should be connected, make GNUM the
                    # same for them...
                    #print(dd, mfac * (cat['D25'][indx[jj]] / 60. + cat['D25'][indx[kk]] / 60.))
                    if dd < (0.5 * mfac * (cat['D25'][indx[jj]] / 60. + cat['D25'][indx[kk]] / 60.)):
                        jndx = np.where(np.logical_or(gnum[indx]==gnum[indx[jj]], gnum[indx]==gnum[indx[kk]]))[0]
                        gnum[indx[jndx]] = gnum[indx[jndx[0]]]
                        mgrp[indx[jndx]] = len(jndx)
            #print(ii, ngroup, gnum[indx], mgrp[indx])

    # Special-case the largest galaxies, looking for neighbhors
    ibig = np.where(cat['D25'] / 60. > dmax)[0]
    if len(ibig) > 0:
        for ii in np.arange(len(ibig)):
           dd = degrees_between(cat['RA'][ibig[ii]], cat['DEC'][ibig[ii]], cat['RA'], cat['DEC'])
           inear = np.where(dd < 0.5*(cat[ibig[ii]]['D25'] + cat['D25']) / 60.)[0]
           if len(inear) > 0:
               for jj in np.arange(len(inear)):
                  indx = np.where(np.logical_or(gnum==gnum[ibig[ii]], gnum==gnum[inear[jj]]))[0]
                  gnum[indx] = gnum[indx[0]]
                  mgrp[indx] = len(indx)

    npergrp, _ = np.histogram(gnum, bins=len(gnum), range=(0, len(gnum)))

    print('Found {} total groups, including:'.format(len(set(gnum))))
    print('  {} groups with 1 member'.format(np.sum( (npergrp == 1) ).astype('int')))
    print('  {} groups with 2 members'.format(np.sum( (npergrp == 2) ).astype('int')))
    print('  {} group(s) with 3-5 members'.format(np.sum( (npergrp >= 3)*(npergrp <= 5) ).astype('int')))
    print('  {} group(s) with 6-10 members'.format(np.sum( (npergrp >= 6)*(npergrp <= 10) ).astype('int')))
    print('  {} group(s) with >10 members'.format(np.sum( (npergrp > 10) ).astype('int')))

    cat['GROUP_ID'] = gnum
    cat['GROUP_MULT'] = mgrp

    I = np.where(cat['GROUP_MULT'] == 1)[0]
    if len(I) > 0:
        cat['GROUP_RA'][I] = cat['RA'][I]
        cat['GROUP_DEC'][I] = cat['DEC'][I]
        cat['GROUP_DIAMETER'][I] = cat['D25'][I]
        cat['GROUP_NAME'][I] = cat['GALAXY'][I]
        cat['GROUP_PRIMARY'][I] = True

    more = np.where(cat['GROUP_MULT'] > 1)[0]
    for group in set(cat['GROUP_ID'][more]):
        I = np.where(cat['GROUP_ID'] == group)[0]
        # Compute the D25-weighted RA, Dec of the group:
        weight = cat[I]['D25']
        cat['GROUP_RA'][I] = np.sum(weight * cat[I]['RA']) / np.sum(weight)
        cat['GROUP_DEC'][I] = np.sum(weight * cat[I]['DEC']) / np.sum(weight)
        # Get the diameter of the group as the distance between the center of
        # the group and the outermost galaxy (plus the diameter of that galaxy,
        # in case it's a big one!).
        dd = degrees_between(cat['RA'][I], cat['DEC'][I], cat['GROUP_RA'][I[0]], cat['GROUP_DEC'][I[0]])
        pad = dd + cat['D25'][I] / 60.0
        cat['GROUP_DIAMETER'][I] = np.max(pad) * 60 # [arcmin]
        if cat['GROUP_DIAMETER'][I[0]] < np.max(cat['D25'][I]):
            print('Should not happen!')
            pdb.set_trace()

        # Assign the group name based on its largest member and also make this
        # galaxy "primary".
        primary = np.argmax(cat['D25'][I])
        cat['GROUP_NAME'][I] = '{}_GROUP'.format(cat['GALAXY'][I][primary])
        cat['GROUP_PRIMARY'][I[primary]] = True

    print('Building a group catalog took {:.3f} min'.format((time.time() - t0)/60))
        
    return cat
    
def main():
    import argparse
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--d25min', type=float, default=20/60., help='Minimum diameter [arcmin].')
    parser.add_argument('--d25max', type=float, default=180.0, help='Maximum diameter [arcmin].')
    parser.add_argument('--nside', type=int, default=512, help='Healpix size.')
    parser.add_argument('--clobber', action='store_true', help='Overwrite existing files.')
    args = parser.parse_args()

    version = LSLGA.io.parent_version()
    parentfile = LSLGA.io.get_parentfile(version=version)
    kdparentfile = LSLGA.io.get_parentfile(version=version, kd=True)

    if os.path.isfile(parentfile) and not args.clobber:
        print('Output file {} exists; use clobber.'.format(parentfile))
        sys.exit(1)

    print('Working on LSLGA {}'.format(version))

    # Read the full Hyperleda catalog and immediately remove unwanted columns--
    parent = LSLGA.io.read_hyperleda(verbose=True)
    parent.remove_columns(('OBJTYPE', 'BT', 'VT', 'IT', 'KT', 'MODBEST',
                           'DIAM_ISO', 'BA_ISO', 'DIAM_B', 'BA_B', 'DIAM_V', 'BA_V',
                           'DIAM_R', 'BA_R', 'DIAM_I', 'BA_I', 'DIAM_K', 'BA_K'))

    # Repair some quantities "by hand". Do this first because some objects get
    # bumped above our diameter cut (e.g., UGC504).
    parent = fix_byhand(parent)

    # Apply a minimum and maximum diameter cut.
    parent = apply_diamcut(parent, args.d25min, args.d25max)

    # Find all galaxies in and out of the DESI footprint.
    parent = in_footprint(parent, nside=args.nside)

    # Add in the LG dwarfs and the DR8-identified "large" galaxies from
    # Stephanie--
    parent = add_localgroup_dwarfs(parent)
    parent = add_rc3(parent)
    parent = add_ngc(parent)
    parent = add_dr8_candidates(parent)

    # Remove known *spurious* large galaxies (based on visual inspection,
    # etc.). We do reject a handful of DR8-supplement galaxies, so be sure to do
    # this step *after* we've added in the DR8 candidates.
    parent = remove_spurious(parent)

    # Build a group catalog--
    print('Skipping group catalog-making!!!')
    #parent = build_group_catalog(parent)

    # Flag galaxies near bright stars--
    parent, kdparent = near_stars(parent)
    
    print('Writing {} galaxies to {}'.format(len(parent), parentfile))
    
    #parent.write(parentfile, overwrite=True)
    hdr = fitsio.FITSHDR()
    hdrversion = 'L{}'.format(version[1:2]) # fragile!
    hdr['LSLGAVER'] = hdrversion
    fitsio.write(parentfile, parent.as_array(), header=hdr, clobber=True)

    # Hack!
    cmd = 'modhead {} LSLGAVER {}'.format(parentfile, hdrversion)
    _ = os.system(cmd)

    print('Writing {}'.format(kdparentfile))
    cmd = 'startree -i {} -o {} -T -P -k -n largegals'.format(parentfile, kdparentfile)
    #print(cmd)
    _ = os.system(cmd)

    cmd = 'modhead {} LSLGAVER {}'.format(kdparentfile, hdrversion)
    _ = os.system(cmd)

if __name__ == '__main__':
    main()

