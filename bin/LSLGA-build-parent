#!/usr/bin/env python

"""Generate the parent sample of large galaxies.

Note that a D(25) maximum cut of 100 arcmin throws out LMC=ESO056-115,
SMC=NGC0292, M31=NGC224, and the Sagittarius Dwarf.

            GALAXY                    RA                 DEC            D25
            str29                  float64             float64        float32
----------------------------- ------------------ ------------------- ----------
ESO056-115                            80.8941495  -69.75610400000001   645.6542
SAGITTARIUS_DWARF_SPHEROIDAL          283.762899         -30.4784401  449.77997
NGC0292                               13.1583105  -72.80022659999999  299.91626
NGC0224                               10.6846845          41.2689778  177.82794


####
v4.0

* Change d25min from 20/60 arcsec to 45 arcsec.

####
v3.0

* Change d25min from 20/60 arcsec to 60 arcsec.

####
v2.0

Read 1436176 objects from /Users/ioannis/research/projects/LSLGA/sample/v2.0/hyperleda-d25min10-18nov14.fits
Read 1436176 objects from /Users/ioannis/research/projects/LSLGA/sample/v2.0/hyperleda-d25min10-18nov14-allwise.fits
  Identified 1379531/1436176 (96.06%) objects with AllWISE photometry.
  Removed 13273/1436176 (0.92%) objects with no magnitude estimate.
  Removed 887102/1422903 (62.34%) objects with D(25) < 20.000 arcsec and D(25) > 10000.000 arcmin.
  Removed 509/535801 (0.09%) low surface-brightness galaxies.
  Removed 2585/535292 (0.48%) SDSS galaxies inside another large galaxy.
Read 20070 DESI tiles from /Users/ioannis/research/projects/LSLGA/sample/desi-tiles.fits
  Identified 287853/532707 (54.04%) galaxies inside and 244854/532707 (45.96%) galaxies outside the DESI footprint.
Read 2557319 Tycho-2 stars with B<99.0.
  Found 6068/532707 (1.14%) galaxies near a bright (Tycho-2) star.
Final sample size: 532707 galaxies.
Writing 532707 galaxies to /Users/ioannis/research/projects/LSLGA/sample/v2.0/LSLGA-v2.0.fits
Writing /Users/ioannis/research/projects/LSLGA/sample/v2.0/LSLGA-v2.0.kd.fits

"""
import os, sys, argparse, time, pdb
import numpy as np
import matplotlib.pyplot as plt

import fitsio
import astropy.table
import healpy as hp

import LSLGA.io
import LSLGA.misc

def remove_spurious(parent):

    spurgal = np.array([
        # https://github.com/moustakas/LSLGA/issues/14
        'PGC051192', 
        'UGC10822',
        'PGC1944170',
        'PGC5955876',
        'SDSSJ021529.42+010322.6',
        # visual inspection
        'SDSSJ083809.55+251926.4',
        # added since making v3.0
        '2MASXJ21412930+0053356',
        'SDSSJ140511.30+060559.4',
        ])

    gal = np.array([onegal.strip() for onegal in parent['GALAXY']])

    return ~np.isin(gal, spurgal)

def build_parent(d25min=0.75, d25max=1e4, linking_length=2, verbose=False):
    """Build the parent catalog.

    linking_length, d25min, and d25max all in arcmin
    
    """
    import astropy.units as u
    from astropy.table import Table, Column
    from astropy.coordinates import SkyCoord
    
    from astrometry.util.starutil import arcsec_between
    from astrometry.libkd.spherematch import tree_build_radec, tree_search_radec, trees_match, tree_open
    from pydl.pydlutils.spheregroup import spheregroup

    version = LSLGA.io.parent_version()
    sandboxdir = os.path.join(LSLGA.io.sample_dir(), version, 'sandbox')
    if not os.path.isdir(sandboxdir):
        os.makedirs(sandboxdir, exist_ok=True)

    # Read the full Hyperleda catalog and assign a unique ID.
    leda = LSLGA.io.read_hyperleda(verbose=True)
    parent = leda.copy()
    parent.add_column(Column(name='LSLGA_ID', length=len(parent), dtype='i8'), index=0)
    parent['LSLGA_ID'] = np.arange(len(parent))

    # Apply a minimum and maximum diameter cut.
    diamcut = (parent['D25'] >= d25min) * (parent['D25'] <= d25max)
    print('  Removed {}/{} ({:.2f}%) objects with D(25) < {:.3f} arcsec and D(25) > {:.3f} arcmin.'.format(
        np.sum(~diamcut), len(parent), 100*np.sum(~diamcut)/len(parent), d25min*60, d25max))
    if np.sum(diamcut) > 0:
        parent[~diamcut].write(os.path.join(sandboxdir, 'LSLGA-{}-diamcut.fits'.format(version)), overwrite=True)
        parent = parent[diamcut]

    # Repair some incorrect diameters and other properties in Hyperleda.  Use
    # the WXSC (https://vislab.idia.ac.za/research)

    # Sculptor https://github.com/moustakas/LSLGA/issues/27
    # use RC3 valuehttp://leda.univ-lyon1.fr/fG.cgi?n=a106&o=ESO351-030
    fix = np.where(parent['PGC'] == 3589)[0] 
    if len(fix) > 0:
        parent['D25'][fix] = 0.1 * 10**2.700 # [arcmin]

    # NGC4395 https://github.com/moustakas/LSLGA/issues/28
    fix = np.where(parent['PGC'] == 40596)[0] 
    if len(fix) > 0:
        parent['D25'][fix] = 12.8 # [arcmin]
        parent['BA'][fix] = 0.833
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # NGC2366 https://github.com/moustakas/LSLGA/issues/29
    fix = np.where(parent['PGC'] == 21102)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 8.8964 # [arcmin]
        parent['BA'][fix] = 0.5263
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # Require a magnitude estimate.
    magcut = np.isfinite(parent['MAG'])
    print('  Removed {}/{} ({:.2f}%) objects with no magnitude estimate.'.format(
        np.sum(~magcut), len(parent), 100*np.sum(~magcut)/len(parent)))
    if np.sum(magcut) > 0:
        parent[~magcut].write(os.path.join(sandboxdir, 'LSLGA-{}-nomagnitude.fits'.format(version)), overwrite=True)
        parent = parent[magcut]

    # Remove known *spurious* large galaxies (based on visual inspection, etc.).
    notspuriouscut = remove_spurious(parent)
    print('  Removed {}/{} ({:.2f}%) known spurious galaxies.'.format(
        np.sum(~notspuriouscut), len(parent), 100*np.sum(~notspuriouscut)/len(parent)))
    if np.sum(notspuriouscut) > 0:
        parent = parent[notspuriouscut]

    # Apply a surface brightness cut.
    lsbcut = (parent['SB_D25'] > 27) * (parent['D25'] > 0.95)
    print('  Removed {}/{} ({:.2f}%) low surface-brightness galaxies.'.format(
        np.sum(lsbcut), len(parent), 100*np.sum(lsbcut)/len(parent)))
    if np.sum(lsbcut) > 0:
        parent[lsbcut].write(os.path.join(sandboxdir, 'LSLGA-{}-lsb.fits'.format(version)), overwrite=True)
        parent = parent[~lsbcut]

    # Toss out all SDSS galaxies "inside" another galaxy.  Most of these are
    # spurious and the ones that are not will hopefully be fixed by visual
    # inspection and/or will be picked up by the standard pipeline.  Note: as of
    # v4.0 we toss out *all* SDSS and 2MASS galaxies:
    #kdparent = tree_build_radec(parent['RA'], parent['DEC'])
    #sdssingal = np.zeros(len(parent), dtype=bool)
    #for pp in parent:
    #    I = tree_search_radec(kdparent, pp['RA'], pp['DEC'], pp['D25'] / 1.8 / 60) # 1.8 instead of 2...
    #    if len(I) > 1:
    #        isdss = np.array(['SDSS' in gg for gg in parent['GALAXY'][I]])
    #        if np.sum(isdss) > 0:
    #            sdssingal[I[isdss]] = True
    #print('  Removed {}/{} ({:.2f}%) SDSS galaxies inside another large galaxy.'.format(
    #    np.sum(sdssingal), len(parent), 100*np.sum(sdssingal)/len(parent)))    
    #if np.sum(sdssingal) > 0:
    #    parent[sdssingal].write(os.path.join(sandboxdir, 'LSLGA-{}-sdss-in-largegal.fits'.format(
    #        version)), overwrite=True)
    #    parent = parent[~sdssingal]    
    sdss2massgal = np.array(['SDSS' in gg or '2MAS' in gg for gg in parent['GALAXY']])
    print('  Removed {}/{} ({:.2f}%) SDSS or 2MASS galaxies.'.format(
        np.sum(sdss2massgal), len(parent), 100*np.sum(sdss2massgal)/len(parent)))
    if np.sum(sdss2massgal) > 0:
        parent[sdss2massgal].write(os.path.join(sandboxdir, 'LSLGA-{}-sdss2mass.fits'.format(version)), overwrite=True)
        parent = parent[~sdss2massgal]

    # Flag galaxies in and out of the DESI footprint.
    #tiles = LSLGA.io.read_desi_tiles(verbose=verbose)
    #indesi = LSLGA.misc.is_point_in_desi(tiles, parent['RA'], parent['DEC']).astype(bool)

    nside = 512
    parentpix = LSLGA.misc.radec2pix(nside, parent['RA'], parent['DEC'])
    #parentpix = np.hstack((parentpix, hp.pixelfunc.get_all_neighbours(nside, parentpix, nest=True).flatten()))

    dr = 'dr9'
    drdir = os.path.join(LSLGA.io.sample_dir(), dr)
    
    indesi = np.zeros(len(parent), dtype=bool)
    for camera, radius in zip(('90prime', 'mosaic', 'decam'), (0.44, 0.21, 0.17)):
        t0 = time.time()
        if False:        
            kdccds = tree_open(os.path.join(drdir, 'survey-ccds-{}-{}-cut.kd.fits'.format(camera, dr)))
            I, J, dd = trees_match(kdparent, kdccds, np.radians(radius))#, nearest=True)
        else:
            ccds = fitsio.read(os.path.join(drdir, 'survey-ccds-{}-{}-cut.kd.fits'.format(camera, dr)))
            # add the neighboring healpixels to protect against edge effects
            ccdpix = LSLGA.misc.radec2pix(nside, ccds['ra'], ccds['dec'])
            ccdpix = np.hstack((ccdpix, hp.pixelfunc.get_all_neighbours(nside, ccdpix, nest=True).flatten()))
            if np.sum(ccdpix == -1) > 0: # remove the "no neighbors" healpixel, if it exists
                ccdpix = np.delete(ccdpix, np.where(ccdpix == -1)[0])
            I = np.isin(parentpix, ccdpix)
            
        print('Found {} galaxies in {} footprint in {:.1f} sec'.format(np.sum(I), camera, time.time() - t0))
        indesi[I] = True

    #plt.scatter(parent['RA'], parent['DEC'], s=1)
    #plt.scatter(parent['RA'][indesi], parent['DEC'][indesi], s=1)
    #plt.xlim(360, 0)
    #plt.show()
    
    print('  Identified {}/{} ({:.2f}%) galaxies inside and {}/{} ({:.2f}%) galaxies outside the DESI footprint.'.format(
        np.sum(indesi), len(parent), 100*np.sum(indesi)/len(parent), np.sum(~indesi), len(parent),
        100*np.sum(~indesi)/len(parent)))
    parent['IN_DESI'] = indesi

    # Group LSLGA galaxies together for any where their circular radii would
    # overlap.  Use the catalog D25 diameters (in arcmin) multiplied by a
    # scaling factor MFAC (default value 1.25).  The output catalog adds the
    # column GROUPNUM that is -1 for any galaxies outside the footprint
    # (IN_DESI='F'), otherwise has a unique value for each group.  The column
    # MULTGROUP is the multiplicity of that galaxy's group.
    mfac, dmax = 1.25, 10./60

    parent.add_column(Column(name='GROUPNUM', data=np.zeros(len(parent), dtype=np.int16)-1))
    parent.add_column(Column(name='MULTGROUP', data=np.zeros(len(parent), dtype=np.int16)))

    print('Hack!')
    ww = np.where(parent['IN_DESI'] * (cat['RA'] > 200) * (cat['RA'] < 240) * (cat['DEC'] > 20))[0]
    cat = parent[ww]

    # Initialize a unique group number for each galaxy
    gnum = np.arange(len(cat))
    mgrp = np.ones(len(cat))
    
    # First group galaxies within 10 arcmin, setting those to have the same
    # group number
    t0 = time.time()
    ingroup, multgroup, firstgroup, nextgroup = spheregroup(cat['RA'], cat['DEC'], dmax)
    print('Spheregrouping took {:.3f} min'.format((time.time() - t0)/60))

    ngroup = np.count_nonzero(firstgroup != -1)
    for ii in np.arange(ngroup):
        print(ii, ngroup)
        nn = multgroup[ii] # number of galaxies in this group
        if nn > 1:
            # Build INDX as the indices of all objects in this grouping
            indx = np.zeros(nn, dtype=int)
            indx[0] = firstgroup[ii]
            for jj in np.arange(nn-2):
                indx[jj+1] = nextgroup[indx[jj]]
            # Look at all pairs within this grouping to see if they should be connected.
            for jj in np.arange(nn-2):
                for kk in np.arange(jj, nn-1):
                    dd = arcsec_between(cat['RA'][indx[jj]], cat['DEC'][indx[jj]],
                                        cat['RA'][indx[kk]], cat['DEC'][indx[kk]])
                    # If these two galaxies should be connected, make GNUM the
                    # same for them...
                    if dd < 0.5 * mfac * (cat['D25'][indx[jj]] / 60. + cat['D25'][indx[kk]] / 60.):
                        jndx = np.where(gnum[indx]==gnum[indx[jj]] | gnum[indx]==gnum[indx[kk]])[0]
                        gnum[indx[jndx]] = gnum[indx[jndx[0]]]
                        mgrp[indx[jndx]] = len(jndx)
                        
    # Special-case the largest galaxies, looking for neighbhors
    ibig = np.where(cat['D25'] / 60. > dmax)[0]
    nbig = len(ibig)
    for ii in np.arange(nbig):
       print(ii, nbig)
       dd = arcsec_between(cat['RA'][ibig[ii]], cat['DEC'][ibig[ii]], cat['RA'], cat['DEC'])
       inear = np.where(dd < 0.5*(cat[ibig[ii]]['D25'] + cat['D25']) / 60.)[0]
       for jj in np.arange(len(inear)):
          indx = np.where(gnum==gnum[ibig[ii]] | gnum==gnum[inear[jj]])[0]
          gnum[indx] = gnum[indx[0]]
          mgrp[indx] = len(indx)
          
    print('Hack!')
    parent[ww] = cat

    pdb.set_trace()

    #    # Build a group catalog using just the largest galaxies.
    #    mindiam = 0.8
    #    isbig = np.where(parent['D25'] > mindiam)[0]
    #    isbig = isbig[np.argsort(parent['D25'][isbig])[::-1]]
    #    print('Building a group catalog from {} galaxies bigger than {:.2f} arcmin'.format(len(isbig), mindiam))
    #    t0 = time.time()
    #    if False:
    #        grp, mult, frst, nxt = spheregroup(parent['RA'][isbig], parent['DEC'][isbig], linking_length / 60.0)
    #        print('Time = {:.3f} min'.format((time.time() - t0)/60))
    #
    #        npergrp, _ = np.histogram(grp, bins=len(grp), range=(0, len(grp)))
    #        nbiggrp = np.sum(npergrp > 1).astype('int')
    #        nsmallgrp = np.sum(npergrp == 1).astype('int')
    #        ngrp = nbiggrp + nsmallgrp
    #
    #        print('Found {} total groups, including:'.format(ngrp))
    #        print('  {} groups with 1 member'.format(nsmallgrp))
    #        print('  {} groups with 2-5 members'.format(np.sum( (npergrp > 1)*(npergrp <= 5) ).astype('int')))
    #        print('  {} groups with 5-10 members'.format(np.sum( (npergrp > 5)*(npergrp <= 10) ).astype('int')))
    #        print('  {} groups with >10 members'.format(np.sum( (npergrp > 10) ).astype('int')))
    #    else:
    #        igrp = []
    #        npergrp = []
    #        grpra, grpdec, grpradius, grpname = [], [], [], []
    #        for gal in parent[isbig]:
    #            I = tree_search_radec(kdparent, gal['RA'], gal['DEC'], gal['D25'] * 1.5 / 60)
    #            if len(I) == 1:
    #                igrp.append(I)
    #                npergrp.append(len(I))
    #            else:
    #                weight = parent[I]['D25']
    #                ra = np.sum(weight * parent[I]['RA']) / np.sum(weight)
#                dec =  np.sum(weight * parent[I]['DEC']) / np.sum(weight)

    # Flag galaxies near bright stars.
    tycho = LSLGA.io.read_tycho(verbose=True)
    kdparent = tree_build_radec( parent['RA'], parent['DEC'] )

    nearstar = np.zeros( len(parent) ).astype(bool)
    for star in tycho:
        I = tree_search_radec(kdparent, star['RA'], star['DEC'], star['RADIUS'])
        if len(I) > 0:
            nearstar[I] = True
    print('  Found {}/{} ({:.2f}%) galaxies near a bright (Tycho-2) star.'.format(
        np.sum(nearstar), len(parent), 100*np.sum(nearstar)/len(parent)))
    parent['NEAR_BRIGHTSTAR'] = nearstar

    # Remove some unnecessary columns
    parent.remove_columns(('OBJTYPE', 'BT', 'VT', 'IT', 'KT', 'MODBEST',
                           'DIAM_ISO', 'BA_ISO', 'DIAM_B', 'BA_B', 'DIAM_V', 'BA_V',
                           'DIAM_R', 'BA_R', 'DIAM_I', 'BA_I', 'DIAM_K', 'BA_K'))

    print('Final sample size: {} galaxies.'.format(len(parent)))

    return parent, kdparent

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--d25min', type=float, default=20/60., help='Minimum diameter [arcmin].')
    parser.add_argument('--d25max', type=float, default=100, help='Maximum diameter [arcmin].')
    parser.add_argument('--verbose', action='store_true', help='Be verbose!')
    parser.add_argument('--clobber', action='store_true', help='Overwrite existing files.')
    args = parser.parse_args()

    version = LSLGA.io.parent_version()
    parentfile = LSLGA.io.get_parentfile()
    kdparentfile = LSLGA.io.get_parentfile(kd=True)
    
    if os.path.isfile(parentfile) and not args.clobber:
        print('Output file {} exists; use clobber.'.format(parentfile))
        sys.exit(1)

    parent, kdparent = build_parent(verbose=args.verbose, d25min=args.d25min,
                                    d25max=args.d25max)

    if args.verbose:
        print('Writing {} galaxies to {}'.format(len(parent), parentfile))
    
    #parent.write(parentfile, overwrite=True)
    hdr = fitsio.FITSHDR()
    hdrversion = 'L{}'.format(version[1:2]) # fragile!
    hdr['LSLGAVER'] = hdrversion
    fitsio.write(parentfile, parent.as_array(), header=hdr, clobber=True)

    # Hack!
    cmd = 'modhead {} LSLGAVER {}'.format(parentfile, hdrversion)
    _ = os.system(cmd)

    if args.verbose:
        print('Writing {}'.format(kdparentfile))
    cmd = 'startree -i {} -o {} -T -P -k -n largegals'.format(parentfile, kdparentfile)
    #print(cmd)
    _ = os.system(cmd)

    cmd = 'modhead {} LSLGAVER {}'.format(kdparentfile, hdrversion)
    _ = os.system(cmd)

if __name__ == '__main__':
    main()

