#!/usr/bin/env python

"""Generate the parent sample of large galaxies.

"""
import os, sys, time, pdb
import numpy as np
import matplotlib.pyplot as plt

import fitsio
from astropy.table import Table, Column, vstack
from astrometry.libkd.spherematch import match_radec

import LSLGA.io

sampledir = LSLGA.io.sample_dir()
qadir = os.path.join(LSLGA.io.sample_dir(), 'qa')

def _viewer_inspect(cat):
    """Write a little catalog that can be uploaded to the viewer.

    """
    out = cat['GALAXY', 'RA', 'DEC']
    out.rename_column('GALAXY', 'NAME')
    outfile = os.path.join(os.getenv('HOME'), 'tmp', 'viewer.fits')
    print('Writing {} objects to {}'.format(len(cat), outfile))
    out.write(outfile, overwrite=True)

def _imagetool_inspect(cat):
    """Write a little catalog that can be uploaded to
    https://yymao.github.io/decals-image-list-tool/

    """
    outfile = os.path.join(os.getenv('HOME'), 'tmp', 'inspect.txt')
    print('Writing {} objects to {}'.format(len(cat), outfile))
    with open(outfile, 'w') as ff:
        ff.write('name ra dec\n')
        for gal, ra, dec in zip(cat['GALAXY'], cat['RA'], cat['DEC']):
            ff.write('{} {} {}\n'.format(gal, ra, dec))

        
def in_footprint(parent, nside=512):
    """Find all galaxies in the DESI footprint.

    """
    import healpy as hp
    import LSLGA.misc
    
    #tiles = LSLGA.io.read_desi_tiles(verbose=verbose)
    #indesi = LSLGA.misc.is_point_in_desi(tiles, parent['RA'], parent['DEC']).astype(bool)

    parentpix = LSLGA.misc.radec2pix(nside, parent['RA'], parent['DEC'])
    #parentpix = np.hstack((parentpix, hp.pixelfunc.get_all_neighbours(nside, parentpix, nest=True).flatten()))

    dr = 'dr9'
    drdir = os.path.join(sampledir, dr)

    bands = ('g', 'r', 'z')
    camera = ('90prime', 'mosaic', 'decam')

    indesi = dict()
    for cam in camera:
        for band in bands:
            indesi.update({'{}_{}'.format(cam, band): np.zeros(len(parent), dtype=bool)})

    #indesi = np.zeros(len(parent), dtype=bool)
    t0 = time.time()
    for cam, radius in zip(camera, (0.44, 0.21, 0.17)):
        if False:
            from astrometry.libkd.spherematch import trees_match, tree_open
            kdccds = tree_open(os.path.join(drdir, 'survey-ccds-{}-{}.kd.fits'.format(cam, dr)))
            I, J, dd = trees_match(kdparent, kdccds, np.radians(radius))#, nearest=True)
        else:
            ccdsfile = os.path.join(drdir, 'survey-ccds-{}-{}.kd.fits'.format(cam, dr))
            ccds = fitsio.read(ccdsfile)
            print('Read {} CCDs from {}'.format(len(ccds), ccdsfile))

            for band in bands:
                ww = ccds['filter'] == band
                if np.sum(ww) > 0:
                    # add the neighboring healpixels to protect against edge effects
                    ccdpix = LSLGA.misc.radec2pix(nside, ccds['ra'][ww], ccds['dec'][ww])
                    ccdpix = np.hstack((ccdpix, hp.pixelfunc.get_all_neighbours(nside, ccdpix, nest=True).flatten()))
                    if np.sum(ccdpix == -1) > 0: # remove the "no neighbors" healpixel, if it exists
                        ccdpix = np.delete(ccdpix, np.where(ccdpix == -1)[0])
                    I = np.isin(parentpix, ccdpix)
                    indesi['{}_{}'.format(cam, band)][I] = True
                else:
                    I = [False]
                #print('Found {} galaxies in {} {} footprint in {:.1f} sec'.format(np.sum(I), cam, time.time() - t0))
                print('  Found {} galaxies in {} {} footprint.'.format(np.sum(I), cam, band))
    print('Total time to find galaxies in footprint = {:.1f} sec'.format(time.time() - t0))
    
    parent['IN_DESI_NORTH'] = indesi['90prime_g'] | indesi['90prime_r'] | indesi['mosaic_z']
    parent['IN_DESI_NORTH_GRZ'] = indesi['90prime_g'] & indesi['90prime_r'] & indesi['mosaic_z']

    parent['IN_DESI_SOUTH'] = indesi['decam_g'] | indesi['decam_r'] | indesi['decam_z']
    parent['IN_DESI_SOUTH_GRZ'] = indesi['decam_g'] & indesi['decam_r'] & indesi['decam_z']
    
    parent['IN_DESI'] = parent['IN_DESI_NORTH'] | parent['IN_DESI_SOUTH']
    parent['IN_DESI_GRZ'] = parent['IN_DESI_NORTH_GRZ'] | parent['IN_DESI_SOUTH_GRZ']

    #plt.scatter(parent['RA'], parent['DEC'], s=1)
    #plt.scatter(parent['RA'][indesi], parent['DEC'][indesi], s=1)
    #plt.xlim(360, 0)
    #plt.show()

    #bb = parent[parent['IN_DESI_NORTH_GRZ'] & parent['IN_DESI_SOUTH_GRZ']]
    #plt.scatter(bb['RA'], bb['DEC'], s=1)
    #plt.xlim(300, 90) ; plt.ylim(30, 36)
    #plt.axhline(y=32.375, color='k')
    #plt.xlabel('RA') ; plt.ylabel('Dec')
    #plt.show()
    
    print('  Identified {}/{} ({:.2f}%) galaxies inside and {}/{} ({:.2f}%) galaxies outside the DESI footprint.'.format(
        np.sum(parent['IN_DESI']), len(parent), 100*np.sum(parent['IN_DESI'])/len(parent), np.sum(~parent['IN_DESI']),
        len(parent), 100*np.sum(~parent['IN_DESI'])/len(parent)))

    return parent

def near_stars(parent):
    """Flag galaxies near bright stars.

    """
    from astrometry.libkd.spherematch import tree_build_radec, tree_search_radec

    tycho = LSLGA.io.read_tycho(verbose=True)
    kdparent = tree_build_radec(parent['RA'], parent['DEC'])

    nearstar = np.zeros( len(parent) ).astype(bool)
    for star in tycho:
        I = tree_search_radec(kdparent, star['RA'], star['DEC'], star['RADIUS'])
        if len(I) > 0:
            nearstar[I] = True
    print('  Found {}/{} ({:.2f}%) galaxies near a bright (Tycho-2) star.'.format(
        np.sum(nearstar), len(parent), 100*np.sum(nearstar)/len(parent)))
    parent['NEAR_BRIGHTSTAR'] = nearstar

    return parent, kdparent
    
def apply_diamcut(parent, d25min, d25max):
    """Apply the diameter cuts.

    Note that a D(25) maximum cut of 100 arcmin throws out LMC=ESO056-115,
    SMC=NGC0292, M31=NGC224, and the Sagittarius Dwarf.

                GALAXY                    RA                 DEC            D25
                str29                  float64             float64        float32
    ----------------------------- ------------------ ------------------- ----------
    ESO056-115                            80.8941495  -69.75610400000001   645.6542
    SAGITTARIUS_DWARF_SPHEROIDAL          283.762899         -30.4784401  449.77997
    NGC0292                               13.1583105  -72.80022659999999  299.91626
    NGC0224                               10.6846845          41.2689778  177.82794

    """
    diamcut = (parent['D25'] >= d25min) * (parent['D25'] <= d25max)
    print('  Removed {}/{} ({:.2f}%) objects with D(25) < {:.3f} arcsec and D(25) > {:.3f} arcmin.'.format(
        np.sum(~diamcut), len(parent), 100*np.sum(~diamcut)/len(parent), d25min*60, d25max))
    if np.sum(diamcut) > 0:
        #parent[~diamcut].write(os.path.join(qadir, 'LSLGA-{}-diamcut.fits'.format(version)), overwrite=True)
        parent = parent[diamcut]

    return parent

def fix_byhand(parent):
    """Repair incorrect diameters and other properties in Hyperleda "by hand".

    See also WXSC - https://vislab.idia.ac.za/research
    
    """
    print('Repairing some quantities by-hand.')
    
    # PGC1035237, Leda coordiantes are totally wrong!
    fix = np.where(parent['PGC'] == 1035237)[0]
    if len(fix) > 0:
        parent['RA'][fix] = 31.8505
        parent['DEC'][fix] = -6.2346

    # PGC040184=VCC0619, use geometry from NED
    # https://ned.ipac.caltech.edu/byname?objname=PGC40184&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 40184)[0]
    if len(fix) > 0:
        parent['RA'][fix] = 185.770708
        parent['DEC'][fix] = 15.931667
        parent['PA'][fix] = 70.0 # eye-balled
        
    # NGC5474, use D25, PA, and BA from NED
    # https://ned.ipac.caltech.edu/byname?objname=ngc5474&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 50216)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1*10**1.68
        parent['PA'][fix] = 97.5
        parent['BA'][fix] = 0.05
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # PGC170137, fix the PA--not sure why it's not populated
    # http://leda.univ-lyon1.fr/fG.cgi?n=a103&o=PGC170137
    fix = np.where(parent['PGC'] == 170137)[0]
    if len(fix) > 0:
        parent['PA'][fix] = 42.0

    # NGC4526, use PA from NED
    # https://ned.ipac.caltech.edu/byname?objname=ngc779&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 41772)[0]
    if len(fix) > 0:
        parent['PA'][fix] = 113.0

    # PGC007900, use D25 from NED and visually determined PA
    # https://ned.ipac.caltech.edu/byname?objname=PGC007900&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 7900)[0]
    if len(fix) > 0:
        parent['PA'][fix] = 65.0
        parent['D25'][fix] = 0.1 * 10**1.51 # [arcmin]
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])
        
    # NGC5364, use PA and D25 from RC3/NED
    # https://ned.ipac.caltech.edu/byname?objname=ngc5364&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 49555)[0]
    if len(fix) > 0:
        parent['PA'][fix] = 30.0
        parent['BA'][fix] = 0.65
        parent['D25'][fix] = 0.1 * 10**1.83 # [arcmin]
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # NGC0779, use value from RC3
    # https://ned.ipac.caltech.edu/byname?objname=ngc779&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 7544)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1 * 10**1.6 # [arcmin]
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # NGC4448, use values from RC3
    # https://ned.ipac.caltech.edu/byname?objname=ngc4448&hconst=67.8&omegam=0.308&omegav=0.692&wmap=4&corr_z=1
    fix = np.where(parent['PGC'] == 40988)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 0.1 * 10**1.59 # [arcmin]
        parent['BA'][fix] = 10**(-0.44)
        parent['PA'][fix] = 94.0
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # NGC4395 https://github.com/moustakas/LSLGA/issues/28
    fix = np.where(parent['PGC'] == 40596)[0] 
    if len(fix) > 0:
        parent['D25'][fix] = 12.8 # [arcmin]
        parent['BA'][fix] = 0.833
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    # NGC2366 https://github.com/moustakas/LSLGA/issues/29
    fix = np.where(parent['PGC'] == 21102)[0]
    if len(fix) > 0:
        parent['D25'][fix] = 8.8964 # [arcmin]
        parent['BA'][fix] = 0.5263
        parent['SB_D25'][fix] = parent['MAG'][fix] + 2.5 * np.log10( np.pi * (60/2)**2 ) + \
          5 * np.log10(parent['D25'][fix])

    return parent

def add_localgroup_dwarfs(parent):
    """LG dwarfs

    """
    from astropy.table import hstack
    
    print('Adding in the LG dwarfs.')
    dwarfs = LSLGA.io.read_localgroup_dwarfs()
    #dwarfs = dwarfs[(~dwarfs['IGNORE']) * (~dwarfs['RESOLVED'])] # remove these below

    m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], dwarfs['RA'], dwarfs['DEC'], 60/3600.0, nearest=True)
    dwarfs['PGC'][m2] = parent['PGC'][m1]
   
    if False:
        print(hstack((parent['GALAXY', 'RA', 'DEC', 'D25'][m1], dwarfs['GALAXY', 'ONAME', 'RA', 'DEC', 'D25', 'RECNO'][m2])))
        from astropy.stats import sigma_clipped_stats
        print(sigma_clipped_stats(parent['D25'][m1]/dwarfs['D25'][m2], sigma=3))
        fig, ax = plt.subplots(1, 3, figsize=(12, 4))
        ax[0].scatter(parent['D25'][m1], dwarfs['D25'][m2])
        ax[1].scatter(parent['PA'][m1], dwarfs['PA'][m2]) ; ax[1].set_xlim(-5, 184) ; ax[1].set_ylim(-5, 184)
        ax[2].scatter(parent['BA'][m1], dwarfs['BA'][m2]) ; ax[2].set_xlim(0, 1) ; ax[2].set_ylim(0, 1)
        plt.show()

    # Make the dwarfs catalog "look" like the parent Hyperleda catalog and assign IDs starting at 3000000.
    moredwarfs = Table()
    for col in parent.colnames:
        moredwarfs[col] = np.zeros(len(dwarfs), dtype=parent[col].dtype)
    for col in dwarfs.colnames:
        if col in moredwarfs.colnames:
            moredwarfs[col] = dwarfs[col]

    # Remove the duplicates and stack.
    keep = np.delete(np.arange(len(parent)), m1)
    parent = vstack((parent[keep], moredwarfs))
    #parent = parent[np.argsort(parent['LSLGA_ID'])]

    # Finally, remove the dwarfs that are so sparse that we don't care about
    # them and the dwarfs that are so resolved (Fornax & Sculptor) that we
    # actually want to treat them as globular cluster (i.e., "force PSF").
    rem = np.where(np.logical_or(dwarfs['IGNORE'], dwarfs['RESOLVED']))[0]
    m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], dwarfs['RA'][rem],
                              dwarfs['DEC'][rem], 60/3600.0, nearest=True)
    keep = np.delete(np.arange(len(parent)), m1)
    parent = parent[keep]

    return parent

def add_dr8_candidates(parent, startindx=5000000):
    """Read the set of "large" galaxies identified by Stephanie Juneau from the DR8
    catalogs.

    """
    print('Supplementing the LSGLA with the DR8 large galaxies.')

    northfile = os.path.join(sampledir, 'dr8galaxies_gt14_north.fits')
    north = Table(fitsio.read(northfile, upper=True))
    print('Read {} galaxies from {}'.format(len(north), northfile))

    southfile = os.path.join(sampledir, 'dr8galaxies_gt14_south.fits')
    south = Table(fitsio.read(southfile, upper=True))
    print('Read {} galaxies from {}'.format(len(south), southfile))

    nkeep = np.where((north['DEC'] > 32.375) * (north['VI_FLAG'] == 'Y'))[0]
    skeep = np.where((south['DEC'] < 32.375) * (south['VI_FLAG'] == 'Y'))[0]

    print('Add in a minimum d25 for the sdss-supplemented galaxies!!!!!!!!!')

    if False:
        plt.scatter(north['RA'], north['DEC'], label='North')
        plt.scatter(south['RA'], south['DEC'], label='South')
        plt.scatter(north['RA'][nkeep], north['DEC'][nkeep], label='North Keep')
        plt.scatter(south['RA'][skeep], south['DEC'][skeep], label='South Keep') 
        plt.legend() ; plt.axhline(y=32.375, color='k') ; plt.show()

    # Resolve north & south
    supp = vstack((north[nkeep], south[skeep]))

    # Assign IDs starting at startindx.
    supp.add_column(Column(name='LSLGA_ID', data=startindx + np.arange(len(supp))), index=0)
    supp.rename_column('TYPE', 'OBJTYPE')

    # Make the supplemental catalog "look" like the parent Hyperleda catalog.
    out = Table()
    for col in parent.colnames:
        out[col] = np.zeros(len(supp), dtype=parent[col].dtype)
    for col in supp.colnames:
        if col in out.colnames:
            out[col] = supp[col]
    #out['OBJTYPE'] = 'G'

    # Get the geometry from the Tractor fit--
    #print(set(supp['TYPE']))
    for igal, gal in enumerate(supp):
        out['GALAXY'][igal] = 'DR8-{}-{}'.format(supp['BRICKID'][igal], supp['OBJID'][igal])
        #out['GALAXY'][igal] = 'DR8-{}'.format(supp['LS_ID'][igal])
        out['MAG'][igal] = supp['MAG_R'][igal]

        typ = gal['OBJTYPE'].strip()
        if typ == 'DEV':
            ee = np.hypot(gal['SHAPEDEV_E1'], gal['SHAPEDEV_E2'])
            r50 = gal['SHAPEDEV_R'] # [arcsec]
            pa = 180 - (-np.rad2deg(np.arctan2(gal['SHAPEDEV_E2'], gal['SHAPEDEV_E1']) / 2))
        elif typ == 'EXP':
            ee = np.hypot(gal['SHAPEEXP_E1'], gal['SHAPEEXP_E2'])
            r50 = gal['SHAPEEXP_R'] # [arcsec]
            pa = 180 - (-np.rad2deg(np.arctan2(gal['SHAPEEXP_E2'], gal['SHAPEEXP_E1']) / 2))
        elif typ == 'COMP':
            fracdev = gal['FRACDEV']
            eeexp = np.hypot(gal['SHAPEEXP_E1'], gal['SHAPEEXP_E2'])
            eedev = np.hypot(gal['SHAPEDEV_E1'], gal['SHAPEDEV_E2'])
            paexp = 180 - (-np.rad2deg(np.arctan2(gal['SHAPEEXP_E2'], gal['SHAPEEXP_E1']) / 2))
            padev = 180 - (-np.rad2deg(np.arctan2(gal['SHAPEDEV_E2'], gal['SHAPEDEV_E1']) / 2))
            r50exp = gal['SHAPEEXP_R']
            r50dev = gal['SHAPEDEV_R']
            if False:
                ee = fracdev * eedev + (1 - fracdev) * eeexp
                pa = fracdev * padev + (1 - fracdev) * paexp            
                r50 = fracdev * r50dev + (1 - fracdev) * r50exp # [arcsec]
            else:
                if r50dev >= r50exp:
                    ee = eedev
                    pa = padev
                    r50 = r50dev
                else:
                    ee = eeexp
                    pa = paexp
                    r50 = r50exp
        else:
            print('Doom!')
            pdb.set_trace()
                
        ba = (1 - ee) / (1 + ee)
        pa = pa % 180
        theta = (270 - pa) % 180
        d25 = 1.4 * 2 * r50 / 60.0 # radius-->diameter and then r50-->R(25) fudge factor [arcmin]

        #if (supp['BRICKID'][igal] == 628872) * (supp['OBJID'][igal] == 3436):
        #    pdb.set_trace()

        out['BA'][igal] = ba.astype('f4')
        out['PA'][igal] = pa.astype('f4')
        out['D25'][igal] = d25.astype('f4')

    out['SB_D25'] = (out['MAG'] + 2.5 * np.log10(np.pi * (60/2)**2) + 5 * np.log10(out['D25'])).astype('f4')

    # Double-check for duplicates
    m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], out['RA'], out['DEC'], 3/3600.0, nearest=True)
    assert(len(m1) == 0)

    parent = vstack((parent, out))

    return parent

def remove_spurious(parent):
    """Remove spurious galaxies.

    """
    # Read the file from Schlegel--
    rejfile = os.path.join(sampledir, 'lslga-dr8-psf-reject.txt')
    rejid, rejra, rejdec = np.loadtxt(rejfile, unpack=True)
    print('Read {} spurious galaxies from {}'.format(len(rejid), rejfile))
    rejgal = parent[np.isin(parent['LSLGA_ID'], rejid)]['GALAXY'].data

    rejfile = os.path.join(sampledir, 'lslga-spurious.txt')
    spurgal = np.loadtxt(rejfile, dtype=str)
    print('Read spurious {} galaxies from {}'.format(len(spurgal), rejfile))

    rejgalfinal = np.unique(np.concatenate((spurgal, rejgal)))

    gal = np.array([onegal.strip() for onegal in parent['GALAXY']])
    #rejgal = parent[~np.isin(parent['GALAXY'], rejgalaxies)]

    notspuriouscut = ~np.isin(gal, rejgalfinal)

    print('  Removed {}/{} ({:.2f}%) known spurious galaxies.'.format(
        np.sum(~notspuriouscut), len(parent), 100*np.sum(~notspuriouscut)/len(parent)))
    if np.sum(notspuriouscut) > 0:
        parent = parent[notspuriouscut]

    # Require a magnitude estimate. Unfortunately many of these are real
    # galaxies, although either their positions or their geometry is totally
    # unreliable.
    #_viewer_inspect(parent[np.isnan(parent['MAG']) * parent['IN_DESI']])
    magcut = np.isfinite(parent['MAG'])
    print('  Removed {}/{} ({:.2f}%) objects with no magnitude estimate.'.format(
        np.sum(~magcut), len(parent), 100*np.sum(~magcut)/len(parent)))
    if np.sum(magcut) > 0:
        #parent[~magcut].write(os.path.join(sandboxdir, 'LSLGA-{}-nomagnitude.fits'.format(version)), overwrite=True)
        parent = parent[magcut]

    # Visually inspect all the SDSS galaxies above a certain surface brightness;
    # most of these are spurious, but there are many we want to keep.
    #w1 = np.where(parent['IN_DESI'] * (parent['SB_D25'] > 26) * (parent['D25'] <= 0.9))[0]
    #w2 = np.where(['SDSS' in gg for gg in parent['GALAXY'][w1]])[0]
    #_imagetool_inspect(parent[w1][w2])

    #ww = np.where(parent['IN_DESI'] * (parent['SB_D25'] > 27))[0]
    #_imagetool_inspect(parent[ww])
    
    #ww = np.where(parent['IN_DESI'])[0]
    #plt.clf() #; plt.scatter(parent['MAG'][ww], parent['SB_D25'][ww], s=1)
    ##plt.scatter(parent['MAG'][ww][ii], parent['SB_D25'][ww][ii], s=1, color='orange', alpha=0.5)
    #plt.clf() ; plt.scatter(parent['D25'][ww], parent['SB_D25'][ww], s=1)
    ##plt.scatter(parent['D25'][ww][ii], parent['SB_D25'][ww][ii], s=1, color='orange', alpha=0.5)
    ##plt.axhline(y=27, ls='-', color='k')
    #plt.xscale('log')
    #plt.savefig('junk3.png')
    
    # Check all the galaxies with b/a=1--they're OK!
    #_viewer_inspect(parent[(parent['BA']==1) * parent['IN_DESI']])

    #print('  Removed {}/{} ({:.2f}%) low surface-brightness galaxies.'.format(
    #    np.sum(lsbcut), len(parent), 100*np.sum(lsbcut)/len(parent)))
    #if np.sum(lsbcut) > 0:
    #    #parent[lsbcut].write(os.path.join(sandboxdir, 'LSLGA-{}-lsb.fits'.format(version)), overwrite=True)
    #    parent = parent[~lsbcut]

    #sdss2massgal = np.array(['SDSS' in gg or '2MAS' in gg or '[' in gg or 'WINGS' in gg for gg in parent['GALAXY']])
    #print('  Removed {}/{} ({:.2f}%) SDSS/2MASS galaxies and galaxies with square brackets in their name!'.format(
    #    np.sum(sdss2massgal), len(parent), 100*np.sum(sdss2massgal)/len(parent)))
    #if np.sum(sdss2massgal) > 0:
    #    if sandbox:
    #        parent[sdss2massgal].write(os.path.join(sandboxdir, 'LSLGA-{}-sdss2mass.fits'.format(
    #            version)), overwrite=True)
    #    parent = parent[~sdss2massgal]

    return parent

def build_group_catalog(cat, mfac=2.0, dmax=10.0/60.0):
    """dmax in arcmin

    Group LSLGA galaxies together where their circular radii would overlap.  Use
    the catalog D25 diameters (in arcmin) multiplied by a scaling factor MFAC.
    The output catalog adds the column GROUP_ID which is unique for each group.
    The column MULT_GROUP is the multiplicity of that galaxy's group.

    """
    from pydl.pydlutils.spheregroup import spheregroup
    from astrometry.util.starutil_numpy import degrees_between

    nchar = np.max([len(gg) for gg in cat['GALAXY']])+6 # add six characters for "_GROUP"
    
    t0 = time.time()
    cat.add_column(Column(name='GROUP_ID', data=np.zeros(len(cat), dtype=np.int)-1))
    cat.add_column(Column(name='GROUP_NAME', length=len(cat), dtype='<U{}'.format(nchar)))
    cat.add_column(Column(name='GROUP_MULT', data=np.zeros(len(cat), dtype=np.int16)))
    cat.add_column(Column(name='GROUP_PRIMARY', data=np.zeros(len(cat), dtype=bool)))
    cat.add_column(Column(name='GROUP_RA', length=len(cat), dtype='f8')) # diameter-weighted center
    cat.add_column(Column(name='GROUP_DEC', length=len(cat), dtype='f8'))
    cat.add_column(Column(name='GROUP_DIAMETER', length=len(cat), dtype='f4'))
    
    # Initialize a unique group number for each galaxy
    gnum = np.arange(len(cat)).astype(np.int)
    mgrp = np.ones(len(cat)).astype(np.int16)
    
    # First group galaxies within 10 arcmin, setting those to have the same
    # group number
    t0 = time.time()
    print('Spheregrouping took...', end='')
    ingroup, group_mult, firstgroup, nextgroup = spheregroup(cat['RA'], cat['DEC'], dmax)
    print('...{:.3f} min'.format((time.time() - t0)/60))

    ngroup = np.count_nonzero(firstgroup != -1)
    for ii in np.arange(ngroup):
        #print(ii, ngroup)
        nn = group_mult[ii] # number of galaxies in this group
        if nn > 1:
            # Build INDX as the indices of all objects in this grouping
            indx = np.zeros(nn, dtype=int)
            indx[0] = firstgroup[ii]
            for jj in np.arange(nn-1):
                indx[jj+1] = nextgroup[indx[jj]]
            # Look at all pairs within this grouping to see if they should be connected.
            for jj in np.arange(nn-1):
                for kk in np.arange(jj, nn):
                    dd = degrees_between(cat['RA'][indx[jj]], cat['DEC'][indx[jj]], cat['RA'][indx[kk]], cat['DEC'][indx[kk]])
                    # If these two galaxies should be connected, make GNUM the
                    # same for them...
                    #print(dd, mfac * (cat['D25'][indx[jj]] / 60. + cat['D25'][indx[kk]] / 60.))
                    if dd < (0.5 * mfac * (cat['D25'][indx[jj]] / 60. + cat['D25'][indx[kk]] / 60.)):
                        jndx = np.where(np.logical_or(gnum[indx]==gnum[indx[jj]], gnum[indx]==gnum[indx[kk]]))[0]
                        gnum[indx[jndx]] = gnum[indx[jndx[0]]]
                        mgrp[indx[jndx]] = len(jndx)
            #print(ii, ngroup, gnum[indx], mgrp[indx])

    # Special-case the largest galaxies, looking for neighbhors
    ibig = np.where(cat['D25'] / 60. > dmax)[0]
    if len(ibig) > 0:
        for ii in np.arange(len(ibig)):
           dd = degrees_between(cat['RA'][ibig[ii]], cat['DEC'][ibig[ii]], cat['RA'], cat['DEC'])
           inear = np.where(dd < 0.5*(cat[ibig[ii]]['D25'] + cat['D25']) / 60.)[0]
           if len(inear) > 0:
               for jj in np.arange(len(inear)):
                  indx = np.where(np.logical_or(gnum==gnum[ibig[ii]], gnum==gnum[inear[jj]]))[0]
                  gnum[indx] = gnum[indx[0]]
                  mgrp[indx] = len(indx)

    npergrp, _ = np.histogram(gnum, bins=len(gnum), range=(0, len(gnum)))

    print('Found {} total groups, including:'.format(len(set(gnum))))
    print('  {} groups with 1 member'.format(np.sum( (npergrp == 1) ).astype('int')))
    print('  {} groups with 2 members'.format(np.sum( (npergrp == 2) ).astype('int')))
    print('  {} group(s) with 3-5 members'.format(np.sum( (npergrp >= 3)*(npergrp <= 5) ).astype('int')))
    print('  {} group(s) with 6-10 members'.format(np.sum( (npergrp >= 6)*(npergrp <= 10) ).astype('int')))
    print('  {} group(s) with >10 members'.format(np.sum( (npergrp > 10) ).astype('int')))

    cat['GROUP_ID'] = gnum
    cat['GROUP_MULT'] = mgrp

    I = np.where(cat['GROUP_MULT'] == 1)[0]
    if len(I) > 0:
        cat['GROUP_RA'][I] = cat['RA'][I]
        cat['GROUP_DEC'][I] = cat['DEC'][I]
        cat['GROUP_DIAMETER'][I] = cat['D25'][I]
        cat['GROUP_NAME'][I] = cat['GALAXY'][I]
        cat['GROUP_PRIMARY'][I] = True

    more = np.where(cat['GROUP_MULT'] > 1)[0]
    for group in set(cat['GROUP_ID'][more]):
        I = np.where(cat['GROUP_ID'] == group)[0]
        # Compute the D25-weighted RA, Dec of the group:
        weight = cat[I]['D25']
        cat['GROUP_RA'][I] = np.sum(weight * cat[I]['RA']) / np.sum(weight)
        cat['GROUP_DEC'][I] = np.sum(weight * cat[I]['DEC']) / np.sum(weight)
        # Get the diameter of the group as the distance between the center of
        # the group and the outermost galaxy (plus the diameter of that galaxy,
        # in case it's a big one!).
        dd = degrees_between(cat['RA'][I], cat['DEC'][I], cat['GROUP_RA'][I[0]], cat['GROUP_DEC'][I[0]])
        pad = dd + cat['D25'][I] / 60.0
        cat['GROUP_DIAMETER'][I] = np.max(pad) * 60 # [arcmin]
        if cat['GROUP_DIAMETER'][I[0]] < np.max(cat['D25'][I]):
            print('Should not happen!')
            pdb.set_trace()

        # Assign the group name based on its largest member and also make this
        # galaxy "primary".
        primary = np.argmax(cat['D25'][I])
        cat['GROUP_NAME'][I] = '{}_GROUP'.format(cat['GALAXY'][I][primary])
        cat['GROUP_PRIMARY'][I[primary]] = True

    print('Building a group catalog took {:.3f} min'.format((time.time() - t0)/60))
        
    return cat
    
#def build_parent(d25min=0.75, d25max=1e4, verbose=False):
#    """Build the parent catalog.
#
#    d25min, and d25max all in arcmin
#    
#    """
#    version = LSLGA.io.parent_version()
#
#    # Read the full Hyperleda catalog and immediately remove unwanted columns--
#    parent = LSLGA.io.read_hyperleda(verbose=True)
#    parent.remove_columns(('OBJTYPE', 'BT', 'VT', 'IT', 'KT', 'MODBEST',
#                           'DIAM_ISO', 'BA_ISO', 'DIAM_B', 'BA_B', 'DIAM_V', 'BA_V',
#                           'DIAM_R', 'BA_R', 'DIAM_I', 'BA_I', 'DIAM_K', 'BA_K'))
#
#    # Apply a minimum and maximum diameter cut.
#    parent = apply_diamcut(parent, d25min, d25max, version)
#
#    # Find all galaxies in and out of the DESI footprint.
#    parent = in_footprint(parent, nside=512)
#
#    # Remove known *spurious* large galaxies (based on visual inspection, etc.).
#    parent = remove_spurious(parent)
#
#    # Repair some quantities "by hand".
#    parent = fix_byhand(parent)
#
#    # Add in the LG dwarfs--
#    parent = add_localgroup_dwarfs(parent)
#
#    # Add in the DR8-identified "large" galaxies from Stephanie--
#    parent = add_dr8_candidates(parent)
#
#    pdb.set_trace()
#
#    #with open('junk.xt', 'w') as ff:
#    #    [ff.write('{}\n'.format(gal)) for gal in np.unique(parent['GALAXY'])]
#    #rr, dd = np.loadtxt('/Users/ioannis/Downloads/vi_not_in_lslga_g_less_17.txt', unpack=True)
#    #m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], rr, dd, 3/3600.0, nearest=True)    
#
#    # Build a group catalog--
#    #ww = np.where((parent['RA'] > 177) * (parent['RA'] < 178) * (parent['DEC'] > -1.5) * (parent['DEC'] < -0.5))[0]
#    #ww = np.where((parent['RA'] > 200) * (parent['RA'] < 240) * (parent['DEC'] > 20))[0]
#    #ww = np.where((parent['RA'] > 193) * (parent['RA'] < 196) * (parent['DEC'] > 26) * (parent['DEC'] < 30))[0]
#    parent = build_group_catalog(parent)
#
#    # Flag galaxies near bright stars--
#    parent, kdparent = near_stars(parent)
#    
#    print('Final sample size: {} galaxies.'.format(len(parent)))
#
#    return parent, kdparent

def main():
    import argparse
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--d25min', type=float, default=20/60., help='Minimum diameter [arcmin].')
    parser.add_argument('--d25max', type=float, default=180.0, help='Maximum diameter [arcmin].')
    parser.add_argument('--nside', type=int, default=512, help='Healpix size.')
    parser.add_argument('--clobber', action='store_true', help='Overwrite existing files.')
    args = parser.parse_args()

    version = LSLGA.io.parent_version()
    parentfile = LSLGA.io.get_parentfile()
    kdparentfile = LSLGA.io.get_parentfile(kd=True)
    
    if os.path.isfile(parentfile) and not args.clobber:
        print('Output file {} exists; use clobber.'.format(parentfile))
        sys.exit(1)

    print('Working on LSLGA {}'.format(version))

    # Read the full Hyperleda catalog and immediately remove unwanted columns--
    parent = LSLGA.io.read_hyperleda(verbose=True)
    parent.remove_columns(('OBJTYPE', 'BT', 'VT', 'IT', 'KT', 'MODBEST',
                           'DIAM_ISO', 'BA_ISO', 'DIAM_B', 'BA_B', 'DIAM_V', 'BA_V',
                           'DIAM_R', 'BA_R', 'DIAM_I', 'BA_I', 'DIAM_K', 'BA_K'))

    # Apply a minimum and maximum diameter cut.
    parent = apply_diamcut(parent, args.d25min, args.d25max)

    # Find all galaxies in and out of the DESI footprint.
    parent = in_footprint(parent, nside=args.nside)

    # Remove known *spurious* large galaxies (based on visual inspection, etc.).
    parent = remove_spurious(parent)

    # Repair some quantities "by hand".
    parent = fix_byhand(parent)

    # Add in the LG dwarfs and the DR8-identified "large" galaxies from
    # Stephanie--
    parent = add_localgroup_dwarfs(parent)
    parent = add_dr8_candidates(parent)

    #with open('junk.xt', 'w') as ff:
    #    [ff.write('{}\n'.format(gal)) for gal in np.unique(parent['GALAXY'])]
    #rr, dd = np.loadtxt('/Users/ioannis/Downloads/vi_not_in_lslga_g_less_17.txt', unpack=True)
    #m1, m2, d12 = match_radec(parent['RA'], parent['DEC'], rr, dd, 3/3600.0, nearest=True)    

    # Build a group catalog--
    #ww = np.where((parent['RA'] > 177) * (parent['RA'] < 178) * (parent['DEC'] > -1.5) * (parent['DEC'] < -0.5))[0]
    #ww = np.where((parent['RA'] > 200) * (parent['RA'] < 240) * (parent['DEC'] > 20))[0]
    #ww = np.where((parent['RA'] > 193) * (parent['RA'] < 196) * (parent['DEC'] > 26) * (parent['DEC'] < 30))[0]
    parent = build_group_catalog(parent)

    # Flag galaxies near bright stars--
    parent, kdparent = near_stars(parent)
    
    print('Writing {} galaxies to {}'.format(len(parent), parentfile))
    
    #parent.write(parentfile, overwrite=True)
    hdr = fitsio.FITSHDR()
    hdrversion = 'L{}'.format(version[1:2]) # fragile!
    hdr['LSLGAVER'] = hdrversion
    fitsio.write(parentfile, parent.as_array(), header=hdr, clobber=True)

    # Hack!
    cmd = 'modhead {} LSLGAVER {}'.format(parentfile, hdrversion)
    _ = os.system(cmd)

    print('Writing {}'.format(kdparentfile))
    cmd = 'startree -i {} -o {} -T -P -k -n largegals'.format(parentfile, kdparentfile)
    #print(cmd)
    _ = os.system(cmd)

    cmd = 'modhead {} LSLGAVER {}'.format(kdparentfile, hdrversion)
    _ = os.system(cmd)

if __name__ == '__main__':
    main()

